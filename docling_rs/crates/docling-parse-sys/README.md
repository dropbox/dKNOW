# docling-parse-sys

Raw FFI bindings to the docling-parse C API.

## Overview

`docling-parse-sys` provides low-level, unsafe FFI (Foreign Function Interface) bindings to the docling-parse C++ library. These bindings are auto-generated by [bindgen](https://github.com/rust-lang/rust-bindgen) from the C header file.

**⚠️ Warning:** This crate exposes unsafe C functions. For safe, idiomatic Rust bindings, use [docling-parse-rs](https://crates.io/crates/docling-parse-rs) instead.

## Installation

Add this to your `Cargo.toml`:

```toml
[dependencies]
docling-parse-sys = "2.58.0"
```

### System Requirements

#### Build Dependencies

- **C++ Compiler:** C++17 or later (GCC 7+, Clang 5+, MSVC 2017+)
- **CMake:** 3.15 or later
- **bindgen:** Rust crate for generating bindings
- **libclang:** Required by bindgen

#### Runtime Dependencies

- **docling-parse C++ library:** Must be built and available
- Located in: `vendor/docling-parse/`

#### Platform Support

- **Linux:** Tested on Ubuntu 20.04+, Fedora, Arch
- **macOS:** Tested on macOS 11+
- **Windows:** Experimental support (requires MSVC)

## Building

The build process:

1. Locates the docling-parse C++ library in `vendor/docling-parse/`
2. Generates Rust bindings from `wrapper.h` using bindgen
3. Links against `libdocling_parse_c.so` (or `.dylib` on macOS)

```bash
# Build (automatically runs build.rs)
cargo build -p docling-parse-sys

# Build release
cargo build -p docling-parse-sys --release
```

### Build Configuration

The `build.rs` script:

```rust
// Link against the C++ library
println!("cargo:rustc-link-search=native={}", lib_path);
println!("cargo:rustc-link-lib=dylib=docling_parse_c");

// Generate bindings from wrapper.h
let bindings = bindgen::Builder::default()
    .header("wrapper.h")
    .generate()
    .expect("Unable to generate bindings");
```

### macOS Specific

On macOS, the build script sets rpath so the dylib can be found:

```rust
#[cfg(target_os = "macos")]
println!("cargo:rustc-link-arg=-Wl,-rpath,{}", lib_path);
```

## Usage

**⚠️ All functions in this crate are unsafe!**

For most use cases, use [docling-parse-rs](https://crates.io/crates/docling-parse-rs) instead, which provides safe wrappers.

### Example (Unsafe)

```rust
use docling_parse_sys::*;
use std::ffi::CString;

unsafe {
    // Create parser
    let loglevel = CString::new("error").unwrap();
    let parser = docling_parser_new(loglevel.as_ptr());
    assert!(!parser.is_null(), "Parser should not be null");

    // Load document
    let doc_key = CString::new("doc1").unwrap();
    let filename = CString::new("example.pdf").unwrap();
    let success = docling_parser_load_document(
        parser,
        doc_key.as_ptr(),
        filename.as_ptr(),
        std::ptr::null(), // No password
    );
    assert!(success, "Failed to load document");

    // Get page count
    let num_pages = docling_parser_number_of_pages(parser, doc_key.as_ptr());
    println!("Document has {} pages", num_pages);

    // Parse first page
    let json_ptr = docling_parser_parse_page_json(parser, doc_key.as_ptr(), 0);
    if !json_ptr.is_null() {
        let json = std::ffi::CStr::from_ptr(json_ptr)
            .to_string_lossy()
            .into_owned();
        println!("Page JSON: {}", json);

        // Free the JSON string
        docling_parser_free_string(json_ptr);
    }

    // Unload document
    docling_parser_unload_document(parser, doc_key.as_ptr());

    // Free parser
    docling_parser_free(parser);
}
```

## C API Functions

The following C functions are exposed (see `wrapper.h` for details):

### Parser Lifecycle

```c
// Create a new parser
DoclingParser* docling_parser_new(const char* loglevel);

// Free the parser
void docling_parser_free(DoclingParser* parser);
```

### Document Management

```c
// Load a PDF document
bool docling_parser_load_document(
    DoclingParser* parser,
    const char* doc_key,
    const char* pdf_path,
    const char* password
);

// Unload a document
bool docling_parser_unload_document(
    DoclingParser* parser,
    const char* doc_key
);

// Check if a document is loaded
bool docling_parser_is_loaded(
    DoclingParser* parser,
    const char* doc_key
);

// Get the number of pages
int docling_parser_number_of_pages(
    DoclingParser* parser,
    const char* doc_key
);
```

### Page Parsing

```c
// Parse a page and return JSON
char* docling_parser_parse_page_json(
    DoclingParser* parser,
    const char* doc_key,
    int page_no
);

// Free a JSON string
void docling_parser_free_string(char* str);
```

## Safety Requirements

When using this crate, you **must** ensure:

### Memory Safety

1. **Valid Pointers:** All pointers must be valid and properly aligned
2. **String Encoding:** All strings must be valid UTF-8 and null-terminated
3. **Lifetime Management:**
   - Don't use parser after calling `docling_parser_free()`
   - Don't use JSON strings after calling `docling_parser_free_string()`
   - Don't use document keys after calling `docling_parser_unload_document()`

### Example: Memory Leak (Wrong)

```rust
unsafe {
    let parser = docling_parser_new(loglevel.as_ptr());

    // Parse page
    let json_ptr = docling_parser_parse_page_json(parser, doc_key.as_ptr(), 0);

    // ❌ MEMORY LEAK: Forgot to free JSON string

    docling_parser_free(parser);
}
```

### Example: Correct Memory Management

```rust
unsafe {
    let parser = docling_parser_new(loglevel.as_ptr());

    // Parse page
    let json_ptr = docling_parser_parse_page_json(parser, doc_key.as_ptr(), 0);

    if !json_ptr.is_null() {
        // Use JSON...

        // ✅ Free JSON string
        docling_parser_free_string(json_ptr);
    }

    // ✅ Free parser
    docling_parser_free(parser);
}
```

## Thread Safety

**The C++ library is NOT thread-safe!**

- Do not share `DoclingParser*` across threads
- Create separate parser instances per thread
- No synchronization primitives are provided

### Example: Multi-threaded (Correct)

```rust
use std::thread;

let handles: Vec<_> = (0..4)
    .map(|_| {
        thread::spawn(|| unsafe {
            // ✅ Each thread creates its own parser
            let loglevel = CString::new("error").unwrap();
            let parser = docling_parser_new(loglevel.as_ptr());

            // Use parser...

            docling_parser_free(parser);
        })
    })
    .collect();

for handle in handles {
    handle.join().unwrap();
}
```

## File Structure

```
docling-parse-sys/
├── build.rs          # Build script (generates bindings)
├── wrapper.h         # C header wrapper
├── src/
│   └── lib.rs        # Includes generated bindings
└── Cargo.toml
```

## Generated Bindings

The bindings are generated at build time and written to `$OUT_DIR/bindings.rs`. They include:

- Function declarations (e.g., `docling_parser_new`)
- Type definitions (e.g., `DoclingParser`)
- Constants (if any)

### Example Generated Code

```rust
extern "C" {
    pub fn docling_parser_new(loglevel: *const c_char) -> *mut DoclingParser;
    pub fn docling_parser_free(parser: *mut DoclingParser);
    // ... more functions
}
```

## Bindgen Configuration

Bindings are generated with these settings:

```rust
bindgen::Builder::default()
    .header("wrapper.h")
    .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
    .generate_comments(false)  // Don't generate doc comments
    .generate()
```

## Testing

The crate includes a basic lifecycle test:

```rust
#[test]
fn test_parser_lifecycle() {
    unsafe {
        // Create parser
        let loglevel = CString::new("error").unwrap();
        let parser = docling_parser_new(loglevel.as_ptr());
        assert!(!parser.is_null());

        // Free parser
        docling_parser_free(parser);
    }
}
```

Run tests:

```bash
cargo test -p docling-parse-sys
```

## Dependencies

### Build Dependencies

- **bindgen:** For generating FFI bindings
- **cc:** For C/C++ compilation (if needed)

### Runtime Dependencies

- **libdocling_parse_c:** The C++ library (must be pre-built)

## Related Crates

- **docling-parse-rs:** Safe Rust wrapper (**recommended**)
- **docling-parse:** Placeholder for C++ library name
- **docling-backend:** Uses docling-parse-rs for PDF processing
- **docling-core:** High-level document processing API

## License

Licensed under the MIT License. See LICENSE file for details.

## Contributing

This crate is part of the docling-rs project. For contribution guidelines, see the main repository.

## References

- **docling-parse C++ library:** https://github.com/docling-project/docling-parse
- **docling-rs repository:** https://github.com/dropbox/dKNOW/docling_rs
- **bindgen:** https://github.com/rust-lang/rust-bindgen

## Why Two Crates?

The separation between `docling-parse-sys` (raw bindings) and `docling-parse-rs` (safe wrapper) follows Rust FFI conventions:

### docling-parse-sys (This Crate)

- **Purpose:** Raw FFI bindings
- **Safety:** All unsafe
- **API:** C-style (pointers, manual memory management)
- **Users:** Only docling-parse-rs should use this

### docling-parse-rs

- **Purpose:** Safe Rust wrapper
- **Safety:** Safe API (no unsafe in public interface)
- **API:** Rust-style (Result, ownership, RAII)
- **Users:** Application code should use this

This pattern:
- Isolates unsafe code to one crate
- Makes safety audits easier
- Provides idiomatic Rust API
- Follows established Rust conventions (e.g., `openssl-sys` → `openssl`)

## Troubleshooting

### Build Failures

**Error:** `libdocling_parse_c.so not found`

- **Solution:** Build the C++ library first
- Location: `vendor/docling-parse/build/`

**Error:** `wrapper.h not found`

- **Solution:** Check that wrapper.h exists in crate root
- Also check that `vendor/docling-parse/src/c_api/docling_parse_c.h` exists

**Error:** `bindgen failed`

- **Solution:** Install libclang: `apt install libclang-dev` (Linux) or `brew install llvm` (macOS)

### Runtime Failures

**Error:** `cannot find -ldocling_parse_c`

- **Solution:** Set `LD_LIBRARY_PATH` (Linux) or `DYLD_LIBRARY_PATH` (macOS):
  ```bash
  export LD_LIBRARY_PATH=$PWD/vendor/docling-parse/build:$LD_LIBRARY_PATH
  ```

**Segfault or Crash**

- **Cause:** Likely a memory safety violation
- **Solution:** Use docling-parse-rs (safe wrapper) instead

## Support

For questions and issues, see the main docling-rs repository issue tracker.
