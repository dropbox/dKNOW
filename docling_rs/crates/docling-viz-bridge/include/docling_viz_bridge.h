// DoclingViz FFI Bridge
// Auto-generated by cbindgen - DO NOT EDIT
//
// This header provides C API bindings for the DoclingViz macOS application
// to interface with the Rust PDF extraction pipeline.


#ifndef DOCLING_VIZ_BRIDGE_H
#define DOCLING_VIZ_BRIDGE_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Total number of stages
 */
#define dlviz_DlvizStage_COUNT 11

/**
 * Document item label (matches `DocItemLabel` in docling-pdf-ml)
 */
enum dlviz_DlvizLabel {
  /**
   * Caption (figure/table caption)
   */
  CAPTION = 0,
  /**
   * Footnote
   */
  FOOTNOTE = 1,
  /**
   * Formula/equation
   */
  FORMULA = 2,
  /**
   * List item
   */
  LIST_ITEM = 3,
  /**
   * Page footer
   */
  PAGE_FOOTER = 4,
  /**
   * Page header
   */
  PAGE_HEADER = 5,
  /**
   * Picture/image
   */
  PICTURE = 6,
  /**
   * Section header
   */
  SECTION_HEADER = 7,
  /**
   * Table
   */
  TABLE = 8,
  /**
   * Regular text
   */
  TEXT = 9,
  /**
   * Title
   */
  TITLE = 10,
  /**
   * Code block
   */
  CODE = 11,
  /**
   * Checkbox (selected)
   */
  CHECKBOX_SELECTED = 12,
  /**
   * Checkbox (unselected)
   */
  CHECKBOX_UNSELECTED = 13,
  /**
   * Document index
   */
  DOCUMENT_INDEX = 14,
  /**
   * Form element
   */
  FORM = 15,
  /**
   * Key-value region
   */
  KEY_VALUE_REGION = 16,
};
typedef int32_t dlviz_DlvizLabel;

/**
 * Result code for FFI operations
 */
enum dlviz_DlvizResult {
  /**
   * Operation succeeded
   */
  SUCCESS = 0,
  /**
   * Invalid argument (null pointer, out of bounds, etc.)
   */
  INVALID_ARGUMENT = -1,
  /**
   * File not found or cannot be read
   */
  FILE_NOT_FOUND = -2,
  /**
   * PDF parsing error
   */
  PARSE_ERROR = -3,
  /**
   * ML inference error
   */
  INFERENCE_ERROR = -4,
  /**
   * Out of memory
   */
  OUT_OF_MEMORY = -5,
  /**
   * Internal error (bug)
   */
  INTERNAL_ERROR = -99,
};
typedef int32_t dlviz_DlvizResult;

/**
 * Pipeline stage identifier
 */
enum dlviz_DlvizStage {
  /**
   * Raw PDF render (no ML processing)
   */
  RAW_PDF = 0,
  /**
   * OCR text detection (`DBNet`)
   */
  OCR_DETECTION = 1,
  /**
   * OCR text recognition (CRNN)
   */
  OCR_RECOGNITION = 2,
  /**
   * Layout detection (YOLO)
   */
  LAYOUT_DETECTION = 3,
  /**
   * Cell-to-cluster assignment
   */
  CELL_ASSIGNMENT = 4,
  /**
   * Empty cluster removal
   */
  EMPTY_CLUSTER_REMOVAL = 5,
  /**
   * Orphan cell detection
   */
  ORPHAN_DETECTION = 6,
  /**
   * `BBox` adjustment iteration 1
   */
  B_BOX_ADJUST1 = 7,
  /**
   * `BBox` adjustment iteration 2
   */
  B_BOX_ADJUST2 = 8,
  /**
   * Final element assembly
   */
  FINAL_ASSEMBLY = 9,
  /**
   * Reading order assignment
   */
  READING_ORDER = 10,
};
typedef int32_t dlviz_DlvizStage;

/**
 * Batch processor that runs in a background thread
 */
typedef struct dlviz_BatchProcessor dlviz_BatchProcessor;

/**
 * Opaque pipeline handle
 */
typedef struct dlviz_DlvizPipeline dlviz_DlvizPipeline;

/**
 * Batch processing status for C FFI
 */
typedef struct dlviz_DlvizBatchStats {
  /**
   * Total documents in batch
   */
  uintptr_t total_docs;
  /**
   * Completed documents
   */
  uintptr_t completed_docs;
  /**
   * Failed documents
   */
  uintptr_t failed_docs;
  /**
   * Is processing running
   */
  bool is_running;
  /**
   * Is processing paused
   */
  bool is_paused;
  /**
   * Current playback speed
   */
  double speed;
} dlviz_DlvizBatchStats;

/**
 * Bounding box in PDF coordinates (origin at bottom-left)
 */
typedef struct dlviz_DlvizBBox {
  /**
   * Left edge X coordinate
   */
  float x;
  /**
   * Bottom edge Y coordinate (PDF coordinates, origin at bottom)
   */
  float y;
  /**
   * Width
   */
  float width;
  /**
   * Height
   */
  float height;
} dlviz_DlvizBBox;

/**
 * COCO format bounding box (absolute pixel coordinates)
 */
typedef struct dlviz_DlvizCocoBBox {
  /**
   * Top-left X coordinate
   */
  float x;
  /**
   * Top-left Y coordinate
   */
  float y;
  /**
   * Width
   */
  float width;
  /**
   * Height
   */
  float height;
  /**
   * Area (width * height)
   */
  float area;
} dlviz_DlvizCocoBBox;

/**
 * Pascal VOC format bounding box (absolute pixel coordinates)
 */
typedef struct dlviz_DlvizVocBBox {
  /**
   * Minimum X coordinate (left edge)
   */
  float xmin;
  /**
   * Minimum Y coordinate (top edge)
   */
  float ymin;
  /**
   * Maximum X coordinate (right edge)
   */
  float xmax;
  /**
   * Maximum Y coordinate (bottom edge)
   */
  float ymax;
} dlviz_DlvizVocBBox;

/**
 * YOLO format bounding box (normalized 0-1 coordinates)
 */
typedef struct dlviz_DlvizYoloBBox {
  /**
   * Center X coordinate (0.0 - 1.0)
   */
  float x_center;
  /**
   * Center Y coordinate (0.0 - 1.0)
   */
  float y_center;
  /**
   * Width (0.0 - 1.0)
   */
  float width;
  /**
   * Height (0.0 - 1.0)
   */
  float height;
} dlviz_DlvizYoloBBox;

/**
 * A detected layout element (bounding box + label + confidence)
 */
typedef struct dlviz_DlvizElement {
  /**
   * Element unique ID within the page
   */
  uint32_t id;
  /**
   * Bounding box in PDF coordinates
   */
  struct dlviz_DlvizBBox bbox;
  /**
   * Element label/class
   */
  dlviz_DlvizLabel label;
  /**
   * Confidence score (0.0 - 1.0)
   */
  float confidence;
  /**
   * Reading order index (-1 if not assigned)
   */
  int32_t reading_order;
} dlviz_DlvizElement;

/**
 * Statistics about a collection of elements
 *
 * Contains counts for each label type
 */
typedef struct dlviz_DlvizElementStats {
  /**
   * Total number of elements
   */
  uintptr_t total_count;
  /**
   * Count of Caption elements
   */
  uintptr_t caption_count;
  /**
   * Count of Footnote elements
   */
  uintptr_t footnote_count;
  /**
   * Count of Formula elements
   */
  uintptr_t formula_count;
  /**
   * Count of `ListItem` elements
   */
  uintptr_t list_item_count;
  /**
   * Count of `PageFooter` elements
   */
  uintptr_t page_footer_count;
  /**
   * Count of `PageHeader` elements
   */
  uintptr_t page_header_count;
  /**
   * Count of `Picture` elements
   */
  uintptr_t picture_count;
  /**
   * Count of `SectionHeader` elements
   */
  uintptr_t section_header_count;
  /**
   * Count of `Table` elements
   */
  uintptr_t table_count;
  /**
   * Count of `Text` elements
   */
  uintptr_t text_count;
  /**
   * Count of `Title` elements
   */
  uintptr_t title_count;
  /**
   * Count of `Code` elements
   */
  uintptr_t code_count;
  /**
   * Count of `CheckboxSelected` elements
   */
  uintptr_t checkbox_selected_count;
  /**
   * Count of `CheckboxUnselected` elements
   */
  uintptr_t checkbox_unselected_count;
  /**
   * Count of `DocumentIndex` elements
   */
  uintptr_t document_index_count;
  /**
   * Count of `Form` elements
   */
  uintptr_t form_count;
  /**
   * Count of `KeyValueRegion` elements
   */
  uintptr_t key_value_region_count;
  /**
   * Average confidence score across all elements
   */
  float avg_confidence;
  /**
   * Minimum confidence score
   */
  float min_confidence;
  /**
   * Maximum confidence score
   */
  float max_confidence;
} dlviz_DlvizElementStats;

/**
 * An OCR text cell (character/word with position)
 */
typedef struct dlviz_DlvizTextCell {
  /**
   * Cell unique ID
   */
  uint32_t id;
  /**
   * Bounding box in PDF coordinates
   */
  struct dlviz_DlvizBBox bbox;
  /**
   * OCR confidence (0.0 - 1.0)
   */
  float confidence;
  /**
   * Assigned element ID (-1 if orphan)
   */
  int32_t element_id;
} dlviz_DlvizTextCell;

/**
 * Snapshot of pipeline state at a specific stage
 */
typedef struct dlviz_DlvizStageSnapshot {
  /**
   * Stage this snapshot represents
   */
  dlviz_DlvizStage stage;
  /**
   * Number of elements
   */
  uintptr_t element_count;
  /**
   * Elements array (caller must not free)
   */
  const struct dlviz_DlvizElement *elements;
  /**
   * Number of text cells
   */
  uintptr_t cell_count;
  /**
   * Text cells array (caller must not free)
   */
  const struct dlviz_DlvizTextCell *cells;
  /**
   * Processing time for this stage (milliseconds)
   */
  double processing_time_ms;
} dlviz_DlvizStageSnapshot;

/**
 * RGBA color for visualization (C-compatible)
 */
typedef struct dlviz_DlvizColor {
  /**
   * Red component (0-255)
   */
  uint8_t r;
  /**
   * Green component (0-255)
   */
  uint8_t g;
  /**
   * Blue component (0-255)
   */
  uint8_t b;
  /**
   * Alpha component (0-255, 255 = opaque)
   */
  uint8_t a;
} dlviz_DlvizColor;

/**
 * Free a batch processor
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`
 * - `batch` must not be used after this call
 */
void dlviz_batch_free(struct dlviz_BatchProcessor *batch);

/**
 * Get batch processing statistics
 *
 * # Arguments
 * - `batch`: Batch processor handle
 *
 * # Returns
 * Current batch processing statistics
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`, or null
 */
struct dlviz_DlvizBatchStats dlviz_batch_get_stats(const struct dlviz_BatchProcessor *batch);

/**
 * Check if batch processing is paused
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`, or null
 */
bool dlviz_batch_is_paused(const struct dlviz_BatchProcessor *batch);

/**
 * Check if batch processing is currently running
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`, or null
 */
bool dlviz_batch_is_running(const struct dlviz_BatchProcessor *batch);

/**
 * Create a new batch processor
 *
 * # Returns
 * Pointer to new batch processor, or null on error
 *
 * # Memory
 * Caller must free with `dlviz_batch_free`
 */
struct dlviz_BatchProcessor *dlviz_batch_new(void);

/**
 * Pause batch processing
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`
 */
dlviz_DlvizResult dlviz_batch_pause(struct dlviz_BatchProcessor *batch);

/**
 * Poll for next batch progress update (non-blocking)
 *
 * Returns a JSON string with progress information, or null if no updates available.
 *
 * # Arguments
 * - `batch`: Batch processor handle
 *
 * # Returns
 * JSON string with `BatchProgress` data, or null if no updates
 *
 * # Memory
 * Caller must free returned string with `dlviz_string_free`
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`
 */
char *dlviz_batch_poll(const struct dlviz_BatchProcessor *batch);

/**
 * Resume batch processing
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`
 */
dlviz_DlvizResult dlviz_batch_resume(struct dlviz_BatchProcessor *batch);

/**
 * Set batch processing playback speed
 *
 * Speed multiplier for visualization. Values <1.0 slow down, >1.0 speed up.
 * Clamped to range [0.1, 10.0].
 *
 * # Arguments
 * - `batch`: Batch processor handle
 * - `speed`: Playback speed multiplier (0.1 to 10.0)
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`
 */
dlviz_DlvizResult dlviz_batch_set_speed(struct dlviz_BatchProcessor *batch, double speed);

/**
 * Start batch processing
 *
 * # Arguments
 * - `batch`: Batch processor handle
 * - `input_dir`: Path to directory containing PDF files
 * - `output_dir`: Path to output directory for results
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`
 * - `input_dir` and `output_dir` must be valid null-terminated C strings
 */
dlviz_DlvizResult dlviz_batch_start(struct dlviz_BatchProcessor *batch,
                                    const char *input_dir,
                                    const char *output_dir);

/**
 * Stop batch processing
 *
 * # Safety
 * - `batch` must be a valid pointer from `dlviz_batch_new`
 */
dlviz_DlvizResult dlviz_batch_stop(struct dlviz_BatchProcessor *batch);

/**
 * Compute the area of a bounding box
 *
 * # Arguments
 * - `bbox`: Bounding box
 *
 * # Returns
 * Area (width * height)
 */
float dlviz_bbox_area(struct dlviz_DlvizBBox bbox);

/**
 * Get the center point of a bounding box
 *
 * # Arguments
 * - `bbox`: Bounding box
 * - `cx`: Output X coordinate of center
 * - `cy`: Output Y coordinate of center
 *
 * # Safety
 * - `cx` must be a valid writable pointer or null
 * - `cy` must be a valid writable pointer or null
 */
void dlviz_bbox_center(struct dlviz_DlvizBBox bbox, float *cx, float *cy);

/**
 * Check if one bounding box contains another
 *
 * # Arguments
 * - `outer`: Outer bounding box
 * - `inner`: Inner bounding box
 *
 * # Returns
 * True if outer completely contains inner
 */
bool dlviz_bbox_contains(struct dlviz_DlvizBBox outer, struct dlviz_DlvizBBox inner);

/**
 * Expand a bounding box by a margin on all sides
 *
 * # Arguments
 * - `bbox`: Original bounding box
 * - `margin`: Margin to add on all sides (can be negative to shrink)
 *
 * # Returns
 * Expanded bounding box
 */
struct dlviz_DlvizBBox dlviz_bbox_expand(struct dlviz_DlvizBBox bbox, float margin);

/**
 * Compute the intersection of two bounding boxes
 *
 * Returns the overlapping region, or a zero-sized box if no overlap.
 *
 * # Arguments
 * - `bbox1`: First bounding box
 * - `bbox2`: Second bounding box
 *
 * # Returns
 * Intersection bounding box (width/height may be 0 if no overlap)
 */
struct dlviz_DlvizBBox dlviz_bbox_intersection(struct dlviz_DlvizBBox bbox1,
                                               struct dlviz_DlvizBBox bbox2);

/**
 * Calculate the Intersection over Union (`IoU`) of two bounding boxes
 *
 * `IoU` is commonly used to evaluate detection accuracy.
 *
 * # Arguments
 * - `bbox1`: First bounding box (PDF coordinates)
 * - `bbox2`: Second bounding box (PDF coordinates)
 *
 * # Returns
 * `IoU` value between 0.0 and 1.0
 */
float dlviz_bbox_iou(struct dlviz_DlvizBBox bbox1, struct dlviz_DlvizBBox bbox2);

/**
 * Check if a bounding box is valid (non-negative dimensions)
 *
 * # Arguments
 * - `bbox`: Bounding box to validate
 *
 * # Returns
 * True if width and height are both non-negative
 */
bool dlviz_bbox_is_valid(struct dlviz_DlvizBBox bbox);

/**
 * Check if two bounding boxes overlap
 *
 * # Arguments
 * - `bbox1`: First bounding box
 * - `bbox2`: Second bounding box
 *
 * # Returns
 * True if the boxes overlap, false otherwise
 */
bool dlviz_bbox_overlaps(struct dlviz_DlvizBBox bbox1, struct dlviz_DlvizBBox bbox2);

/**
 * Scale a bounding box by a factor
 *
 * Useful for converting between different DPI/resolution coordinate systems.
 *
 * # Arguments
 * - `bbox`: Original bounding box
 * - `scale`: Scale factor (e.g., 2.0 doubles size, 0.5 halves size)
 *
 * # Returns
 * Scaled bounding box
 */
struct dlviz_DlvizBBox dlviz_bbox_scale(struct dlviz_DlvizBBox bbox, float scale);

/**
 * Convert a PDF bounding box to COCO format
 *
 * COCO format uses absolute coordinates with origin at top-left.
 * Returns [x, y, width, height] where (x, y) is the top-left corner.
 *
 * # Arguments
 * - `bbox`: PDF bounding box (origin at bottom-left)
 * - `page_height`: Page height in points (needed for Y coordinate conversion)
 *
 * # Returns
 * COCO format bounding box with area pre-calculated
 */
struct dlviz_DlvizCocoBBox dlviz_bbox_to_coco(struct dlviz_DlvizBBox bbox, float page_height);

/**
 * Convert a PDF bounding box to Pascal VOC format
 *
 * VOC format uses absolute coordinates (xmin, ymin, xmax, ymax) with origin at top-left.
 *
 * # Arguments
 * - `bbox`: PDF bounding box (origin at bottom-left)
 * - `page_height`: Page height in points
 *
 * # Returns
 * Pascal VOC format bounding box
 */
struct dlviz_DlvizVocBBox dlviz_bbox_to_voc(struct dlviz_DlvizBBox bbox, float page_height);

/**
 * Convert a PDF bounding box to YOLO format
 *
 * YOLO format uses normalized coordinates (0-1) with center point.
 * PDF coordinates have origin at bottom-left, but YOLO uses top-left.
 *
 * # Arguments
 * - `bbox`: PDF bounding box (origin at bottom-left)
 * - `page_width`: Page width in points
 * - `page_height`: Page height in points
 *
 * # Returns
 * YOLO format bounding box (center point, normalized)
 */
struct dlviz_DlvizYoloBBox dlviz_bbox_to_yolo(struct dlviz_DlvizBBox bbox,
                                              float page_width,
                                              float page_height);

/**
 * Translate a bounding box by an offset
 *
 * # Arguments
 * - `bbox`: Original bounding box
 * - `dx`: X offset (positive moves right)
 * - `dy`: Y offset (positive moves up in PDF coordinates)
 *
 * # Returns
 * Translated bounding box
 */
struct dlviz_DlvizBBox dlviz_bbox_translate(struct dlviz_DlvizBBox bbox, float dx, float dy);

/**
 * Compute the union of two bounding boxes
 *
 * Returns the smallest bounding box that contains both inputs.
 *
 * # Arguments
 * - `bbox1`: First bounding box
 * - `bbox2`: Second bounding box
 *
 * # Returns
 * Union bounding box
 */
struct dlviz_DlvizBBox dlviz_bbox_union(struct dlviz_DlvizBBox bbox1, struct dlviz_DlvizBBox bbox2);

/**
 * Convert a COCO bounding box back to PDF format
 *
 * # Arguments
 * - `coco`: COCO format bounding box
 * - `page_height`: Page height in points
 *
 * # Returns
 * PDF format bounding box (origin at bottom-left)
 */
struct dlviz_DlvizBBox dlviz_coco_to_bbox(struct dlviz_DlvizCocoBBox coco, float page_height);

/**
 * Compute statistics about an array of elements
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `stats`: Output pointer to store computed statistics
 *
 * # Returns
 * `DlvizResult::Success` on success, error code on failure
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 * - `stats` must be a valid writable pointer
 */
dlviz_DlvizResult dlviz_compute_element_stats(const struct dlviz_DlvizElement *elements,
                                              uintptr_t count,
                                              struct dlviz_DlvizElementStats *stats);

/**
 * Count elements completely contained within a region
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `region`: Region to test against
 *
 * # Returns
 * Number of elements whose bounding box is completely inside the region
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
uintptr_t dlviz_count_elements_contained_in_region(const struct dlviz_DlvizElement *elements,
                                                   uintptr_t count,
                                                   struct dlviz_DlvizBBox region);

/**
 * Count elements overlapping with a region
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `region`: Region to test against
 *
 * # Returns
 * Number of elements whose bounding box overlaps the region
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
uintptr_t dlviz_count_elements_in_region(const struct dlviz_DlvizElement *elements,
                                         uintptr_t count,
                                         struct dlviz_DlvizBBox region);

/**
 * Count elements with valid reading order
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 *
 * # Returns
 * Number of elements with `reading_order` >= 0
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
uintptr_t dlviz_count_elements_with_reading_order(const struct dlviz_DlvizElement *elements,
                                                  uintptr_t count);

/**
 * Export all processed pages as a single JSON document
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `pretty`: If true, output will be pretty-printed with indentation
 *
 * # Returns
 * Pointer to null-terminated JSON string containing all pages, or null on error.
 * Caller must free with `dlviz_string_free`.
 *
 * # JSON Structure
 * ```json
 * {
 *   "document": "filename.pdf",
 *   "page_count": 3,
 *   "pages": [
 *     { "page": 0, "stage": "reading_order", "elements": [...], "element_count": N },
 *     { "page": 1, ... },
 *     ...
 *   ]
 * }
 * ```
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`, or null
 */
char *dlviz_export_all_pages_json(const struct dlviz_DlvizPipeline *pipeline, bool pretty);

/**
 * Export page detection results in COCO annotation format
 *
 * Returns a JSON object suitable for inclusion in a COCO dataset's annotations array.
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 * - `image_id`: Image ID for the COCO annotation
 * - `annotation_id_start`: Starting annotation ID (increments for each detection)
 *
 * # Returns
 * Pointer to null-terminated JSON string, or null on error.
 * Caller must free with `dlviz_string_free`.
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`, or null
 */
char *dlviz_export_coco_annotations(const struct dlviz_DlvizPipeline *pipeline,
                                    uintptr_t page_num,
                                    uint32_t image_id,
                                    uint32_t annotation_id_start);

/**
 * Export current pipeline state as JSON
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 *
 * # Returns
 * Pointer to null-terminated JSON string, or null on error.
 * Caller must free with `dlviz_string_free`.
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`, or null
 */
char *dlviz_export_json(const struct dlviz_DlvizPipeline *pipeline, uintptr_t page_num);

/**
 * Export current pipeline state as pretty-printed JSON
 *
 * Same as `dlviz_export_json` but with human-readable formatting.
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 *
 * # Returns
 * Pointer to null-terminated JSON string with indentation, or null on error.
 * Caller must free with `dlviz_string_free`.
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`, or null
 */
char *dlviz_export_json_pretty(const struct dlviz_DlvizPipeline *pipeline, uintptr_t page_num);

/**
 * Export page detection results in YOLO format
 *
 * YOLO format: one line per detection with `class_id x_center y_center width height`
 * All coordinates are normalized to 0-1 range.
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 *
 * # Returns
 * Pointer to null-terminated string in YOLO format, or null on error.
 * Caller must free with `dlviz_string_free`.
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`, or null
 */
char *dlviz_export_yolo(const struct dlviz_DlvizPipeline *pipeline, uintptr_t page_num);

/**
 * Find all elements containing a point
 *
 * Searches through an array of elements and counts how many elements'
 * bounding boxes contain the given point. Optionally fills an output
 * array with the indices.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `x`: X coordinate of point
 * - `y`: Y coordinate of point
 * - `out_indices`: Optional output array to store matching indices (can be null)
 * - `out_capacity`: Capacity of `out_indices` array (ignored if `out_indices` is null)
 *
 * # Returns
 * Number of elements containing the point
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 * - If `out_indices` is not null, it must be valid for at least `out_capacity` elements
 */
uintptr_t dlviz_find_all_elements_at_point(const struct dlviz_DlvizElement *elements,
                                           uintptr_t count,
                                           float x,
                                           float y,
                                           uintptr_t *out_indices,
                                           uintptr_t out_capacity);

/**
 * Find element with highest confidence at a point
 *
 * When multiple elements overlap at a point, returns the index of the
 * element with the highest confidence score.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `x`: X coordinate of point
 * - `y`: Y coordinate of point
 *
 * # Returns
 * Index of highest-confidence element at point, or -1 if none found
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
int32_t dlviz_find_best_element_at_point(const struct dlviz_DlvizElement *elements,
                                         uintptr_t count,
                                         float x,
                                         float y);

/**
 * Find the first element containing a point
 *
 * Searches through an array of elements and returns the index of the first
 * element whose bounding box contains the given point. Returns -1 if no
 * element contains the point.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `x`: X coordinate of point
 * - `y`: Y coordinate of point
 *
 * # Returns
 * Index of first element containing the point, or -1 if none found
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
int32_t dlviz_find_element_at_point(const struct dlviz_DlvizElement *elements,
                                    uintptr_t count,
                                    float x,
                                    float y);

/**
 * Find element with smallest area at a point
 *
 * When multiple elements overlap at a point, returns the index of the
 * element with the smallest bounding box area. Useful for selecting
 * the most specific element when clicking.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `x`: X coordinate of point
 * - `y`: Y coordinate of point
 *
 * # Returns
 * Index of smallest element at point, or -1 if none found
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
int32_t dlviz_find_smallest_element_at_point(const struct dlviz_DlvizElement *elements,
                                             uintptr_t count,
                                             float x,
                                             float y);

/**
 * Get text content of a cell
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 * - `cell_id`: Cell ID from snapshot
 * - `buffer`: Output buffer for UTF-8 text
 * - `buffer_size`: Size of buffer in bytes
 * - `actual_size`: Output actual size needed
 *
 * # Returns
 * Result code
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - `buffer` must be a valid writable buffer of at least `buffer_size` bytes
 * - `actual_size` must be a valid writable pointer
 */
dlviz_DlvizResult dlviz_get_cell_text(const struct dlviz_DlvizPipeline *pipeline,
                                      uintptr_t page_num,
                                      uint32_t cell_id,
                                      char *buffer,
                                      uintptr_t buffer_size,
                                      uintptr_t *actual_size);

/**
 * Get COCO categories for DocItem labels
 *
 * Returns a JSON array of COCO category objects for all label types.
 *
 * # Returns
 * Pointer to null-terminated JSON string, or null on error.
 * Caller must free with `dlviz_string_free`.
 */
char *dlviz_get_coco_categories(void);

/**
 * Find element with a specific reading order index
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `reading_order`: Reading order value to search for
 *
 * # Returns
 * Array index of element with matching reading order, or -1 if not found
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
int32_t dlviz_get_element_by_reading_order(const struct dlviz_DlvizElement *elements,
                                           uintptr_t count,
                                           int32_t reading_order);

/**
 * Get text content of an element
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 * - `element_id`: Element ID from snapshot
 * - `buffer`: Output buffer for UTF-8 text
 * - `buffer_size`: Size of buffer in bytes
 * - `actual_size`: Output actual size needed (including null terminator)
 *
 * # Returns
 * Result code. If buffer is too small, returns Success but `actual_size` > `buffer_size`.
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - `buffer` must be a valid writable buffer of at least `buffer_size` bytes
 * - `actual_size` must be a valid writable pointer
 */
dlviz_DlvizResult dlviz_get_element_text(const struct dlviz_DlvizPipeline *pipeline,
                                         uintptr_t page_num,
                                         uint32_t element_id,
                                         char *buffer,
                                         uintptr_t buffer_size,
                                         uintptr_t *actual_size);

/**
 * Get the bounding box encompassing all elements
 *
 * Computes the smallest bounding box that contains all elements in the array.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `out_bbox`: Output pointer to store the result
 *
 * # Returns
 * `DlvizResult::Success` if at least one element exists, `InvalidArgument` otherwise
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 * - `out_bbox` must be a valid writable pointer
 */
dlviz_DlvizResult dlviz_get_elements_bounds(const struct dlviz_DlvizElement *elements,
                                            uintptr_t count,
                                            struct dlviz_DlvizBBox *out_bbox);

/**
 * Find first element in reading order
 *
 * Returns the array index of the element with the lowest reading order value.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 *
 * # Returns
 * Array index of element with lowest reading order, or -1 if no valid elements
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
int32_t dlviz_get_first_reading_order_element(const struct dlviz_DlvizElement *elements,
                                              uintptr_t count);

/**
 * Find last element in reading order
 *
 * Returns the array index of the element with the highest reading order value.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 *
 * # Returns
 * Array index of element with highest reading order, or -1 if no valid elements
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
int32_t dlviz_get_last_reading_order_element(const struct dlviz_DlvizElement *elements,
                                             uintptr_t count);

/**
 * Find element with the next reading order after a given value
 *
 * Finds the element with the smallest reading order that is greater than
 * the given value. Useful for iterating through elements in reading order.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `current_order`: Current reading order value
 *
 * # Returns
 * Array index of element with next reading order, or -1 if none found
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
int32_t dlviz_get_next_reading_order_element(const struct dlviz_DlvizElement *elements,
                                             uintptr_t count,
                                             int32_t current_order);

/**
 * Get the number of pages in the loaded document
 *
 * # Returns
 * Number of pages, or 0 if no document loaded
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`, or null
 */
uintptr_t dlviz_get_page_count(const struct dlviz_DlvizPipeline *pipeline);

/**
 * Get page dimensions
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 * - `width`: Output width in points
 * - `height`: Output height in points
 *
 * # Returns
 * Result code
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - `width` and `height` must be valid writable pointers
 */
dlviz_DlvizResult dlviz_get_page_size(const struct dlviz_DlvizPipeline *pipeline,
                                      uintptr_t page_num,
                                      float *width,
                                      float *height);

/**
 * Find element with the previous reading order before a given value
 *
 * Finds the element with the largest reading order that is less than
 * the given value. Useful for reverse iteration through reading order.
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `current_order`: Current reading order value
 *
 * # Returns
 * Array index of element with previous reading order, or -1 if none found
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 */
int32_t dlviz_get_prev_reading_order_element(const struct dlviz_DlvizElement *elements,
                                             uintptr_t count,
                                             int32_t current_order);

/**
 * Get the minimum and maximum reading order values in an element array
 *
 * # Arguments
 * - `elements`: Pointer to array of elements
 * - `count`: Number of elements in the array
 * - `out_min`: Output pointer for minimum reading order (can be null)
 * - `out_max`: Output pointer for maximum reading order (can be null)
 *
 * # Returns
 * `DlvizResult::Success` if at least one element with valid reading order exists,
 * `InvalidArgument` otherwise
 *
 * # Safety
 * - `elements` must be valid for `count` elements or null (if count is 0)
 * - If `out_min`/`out_max` are not null, they must be valid writable pointers
 *
 * # Panics
 *
 * This function uses `.unwrap()` on `min()` and `max()` iterators, but they are
 * guarded by an early return that checks `valid_orders.is_empty()` first.
 * The panic is unreachable in normal execution.
 */
dlviz_DlvizResult dlviz_get_reading_order_range(const struct dlviz_DlvizElement *elements,
                                                uintptr_t count,
                                                int32_t *out_min,
                                                int32_t *out_max);

/**
 * Get snapshot of pipeline state at a stage
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 * - `stage`: Stage to get snapshot for
 * - `snapshot`: Output snapshot (must be pre-allocated)
 *
 * # Returns
 * Result code
 *
 * # Note
 * The snapshot contains pointers to internal data that remain valid
 * until the next pipeline operation or free.
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - `snapshot` must be a valid writable pointer to a `DlvizStageSnapshot`
 */
dlviz_DlvizResult dlviz_get_stage_snapshot(const struct dlviz_DlvizPipeline *pipeline,
                                           uintptr_t page_num,
                                           dlviz_DlvizStage stage,
                                           struct dlviz_DlvizStageSnapshot *snapshot);

/**
 * Check if PDF ML pipeline feature is available
 *
 * # Returns
 * `true` if the library was built with `--features pdf-ml` and the
 * ML models can be initialized, `false` otherwise.
 *
 * # Note
 * Even if this returns `true` at library level, individual pipelines
 * may fail to initialize if model files are missing. Use
 * `dlviz_pipeline_has_ml()` to check a specific pipeline instance.
 */
bool dlviz_has_pdf_ml(void);

/**
 * Check if PDF rendering is available
 *
 * Returns true if the library was built with pdfium-render support.
 */
bool dlviz_has_pdf_render(void);

/**
 * Get the visualization color for a label
 *
 * # Arguments
 * - `label`: Label to get color for
 *
 * # Returns
 * RGBA color for the label
 */
struct dlviz_DlvizColor dlviz_label_color(dlviz_DlvizLabel label);

/**
 * Get the total number of label types
 *
 * # Returns
 * Number of distinct label types (17)
 */
uintptr_t dlviz_label_count(void);

/**
 * Get label from integer index
 *
 * # Arguments
 * - `index`: Label index (0-16)
 *
 * # Returns
 * The label, or -1 if index is out of range
 */
int32_t dlviz_label_from_index(uintptr_t index);

/**
 * Get the display name for a label
 *
 * # Arguments
 * - `label`: Label to get name for
 *
 * # Returns
 * Static label name string (do not free)
 */
const char *dlviz_label_name(dlviz_DlvizLabel label);

/**
 * Get the short name for a label (for YOLO/COCO class names)
 *
 * # Arguments
 * - `label`: Label to get short name for
 *
 * # Returns
 * Static short name string suitable for annotation files (do not free)
 */
const char *dlviz_label_short_name(dlviz_DlvizLabel label);

/**
 * Load elements from a JSON file
 *
 * Loads previously saved detection results or corrections for editing.
 *
 * # Arguments
 * - `input_path`: Path to JSON file
 * - `out_elements`: Pointer to array to fill with loaded elements
 * - `out_count`: Pointer to store number of elements loaded
 * - `max_elements`: Maximum number of elements to load
 *
 * # Returns
 * Result code
 *
 * # Safety
 * - `input_path` must be a valid null-terminated UTF-8 string
 * - `out_elements` must be valid for `max_elements` writes
 * - `out_count` must be a valid pointer
 */
dlviz_DlvizResult dlviz_load_elements_from_json(const char *input_path,
                                                struct dlviz_DlvizElement *out_elements,
                                                uintptr_t *out_count,
                                                uintptr_t max_elements);

/**
 * Load a PDF document for processing
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `path`: UTF-8 encoded file path (null-terminated)
 *
 * # Returns
 * Result code
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - `path` must be a valid null-terminated UTF-8 string
 */
dlviz_DlvizResult dlviz_load_pdf(struct dlviz_DlvizPipeline *pipeline, const char *path);

/**
 * Free a pipeline instance
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - `pipeline` must not be used after this call
 */
void dlviz_pipeline_free(struct dlviz_DlvizPipeline *pipeline);

/**
 * Check if a pipeline instance has ML capabilities
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 *
 * # Returns
 * `true` if the pipeline has ML models initialized and ready,
 * `false` if ML is not available or models failed to load.
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`, or null
 */
bool dlviz_pipeline_has_ml(const struct dlviz_DlvizPipeline *pipeline);

/**
 * Create a new pipeline instance
 *
 * # Returns
 * Pointer to new pipeline, or null on error
 *
 * # Memory
 * Caller must free with `dlviz_pipeline_free`
 */
struct dlviz_DlvizPipeline *dlviz_pipeline_new(void);

/**
 * Check if a point is inside a bounding box
 *
 * # Arguments
 * - `bbox`: Bounding box to test
 * - `x`: X coordinate of point
 * - `y`: Y coordinate of point
 *
 * # Returns
 * True if point is inside or on the edge of the bbox
 */
bool dlviz_point_in_bbox(struct dlviz_DlvizBBox bbox, float x, float y);

/**
 * Render all pages of a PDF to visualization PNGs
 *
 * Processes all pages and saves to `output_dir` as:
 * - `{stem}_page_{N:03}_{stage}.png`
 * - `{stem}_page_{N:03}_{stage}.json`
 *
 * # Arguments
 * - `pipeline`: Pipeline instance with loaded PDF
 * - `stage`: Stage to visualize
 * - `scale`: Render scale (2.0 recommended)
 * - `output_dir`: Directory to write output files
 *
 * # Returns
 * Number of pages processed, or negative error code
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - `output_dir` must be a valid null-terminated UTF-8 string
 */
int32_t dlviz_render_all_pages(struct dlviz_DlvizPipeline *pipeline,
                               dlviz_DlvizStage stage,
                               float scale,
                               const char *output_dir);

/**
 * Render a page to RGBA image buffer
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 * - `scale`: Scale factor (1.0 = native resolution)
 * - `width_out`: Output image width
 * - `height_out`: Output image height
 * - `buffer`: Output buffer for RGBA data (4 bytes per pixel)
 * - `buffer_size`: Size of buffer in bytes
 *
 * # Returns
 * Result code. If buffer is too small, returns `InvalidArgument` and sets `width_out`/`height_out`
 * to required dimensions.
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - All output pointers must be valid writable locations
 * - `buffer` must have at least `buffer_size` bytes available
 */
dlviz_DlvizResult dlviz_render_page(const struct dlviz_DlvizPipeline *pipeline,
                                    uintptr_t page_num,
                                    float scale,
                                    uint32_t *width_out,
                                    uint32_t *height_out,
                                    uint8_t *buffer,
                                    uintptr_t buffer_size);

/**
 * Render visualization to PNG file with bounding box overlays
 *
 * Renders the PDF page with colored bounding boxes for each detected element,
 * plus labels and reading order numbers. Also generates a JSON sidecar file.
 *
 * # Arguments
 * - `pipeline`: Pipeline instance with loaded PDF
 * - `page_num`: Page number (0-indexed)
 * - `stage`: Stage to visualize
 * - `scale`: Render scale (2.0 recommended for AI vision)
 * - `output_path`: Path to write PNG file (JSON sidecar written to same name with .json)
 *
 * # Returns
 * Result code
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 * - `output_path` must be a valid null-terminated UTF-8 string
 */
dlviz_DlvizResult dlviz_render_visualization(struct dlviz_DlvizPipeline *pipeline,
                                             uintptr_t page_num,
                                             dlviz_DlvizStage stage,
                                             float scale,
                                             const char *output_path);

/**
 * Run pipeline up to and including the specified stage
 *
 * # Arguments
 * - `pipeline`: Pipeline instance
 * - `page_num`: Page number (0-indexed)
 * - `stage`: Target stage
 *
 * # Returns
 * Result code
 *
 * # Safety
 * - `pipeline` must be a valid pointer from `dlviz_pipeline_new`
 */
dlviz_DlvizResult dlviz_run_to_stage(struct dlviz_DlvizPipeline *pipeline,
                                     uintptr_t page_num,
                                     dlviz_DlvizStage stage);

/**
 * Save corrected elements to a JSON file
 *
 * Saves human-corrected detection results for later validation by the AI judge.
 * The output format matches what `ai_visual_judge.py` expects.
 *
 * # Arguments
 * - `elements`: Array of corrected elements
 * - `count`: Number of elements
 * - `element_texts`: Array of text strings (parallel to elements, can be null entries)
 * - `pdf_name`: Name of the source PDF
 * - `page_num`: Page number (0-indexed)
 * - `page_width`: Page width in PDF points
 * - `page_height`: Page height in PDF points
 * - `output_path`: Path to write JSON file
 *
 * # Returns
 * Result code
 *
 * # Safety
 * - `elements` must be valid for `count` elements
 * - `element_texts` must be valid for `count` elements (can be null pointers)
 * - `pdf_name` and `output_path` must be valid null-terminated UTF-8 strings
 */
dlviz_DlvizResult dlviz_save_corrected_elements(const struct dlviz_DlvizElement *elements,
                                                uintptr_t count,
                                                const char *const *element_texts,
                                                const char *pdf_name,
                                                uintptr_t page_num,
                                                float page_width,
                                                float page_height,
                                                const char *output_path);

/**
 * Get number of pipeline stages
 */
uintptr_t dlviz_stage_count(void);

/**
 * Get stage name
 *
 * # Arguments
 * - `stage`: Stage to get name for
 *
 * # Returns
 * Static stage name string (do not free)
 */
const char *dlviz_stage_name(dlviz_DlvizStage stage);

/**
 * Get count for a specific label from statistics
 *
 * # Arguments
 * - `stats`: Pointer to computed statistics
 * - `label`: Label to get count for
 *
 * # Returns
 * Count for the specified label, or 0 if stats is null
 *
 * # Safety
 * - `stats` must be a valid pointer to a `DlvizElementStats` struct or null
 */
uintptr_t dlviz_stats_get_label_count(const struct dlviz_DlvizElementStats *stats,
                                      dlviz_DlvizLabel label);

/**
 * Free a string returned by FFI functions
 *
 * # Safety
 * - `s` must be a valid pointer from a dlviz_* function
 * - `s` must not be used after this call
 */
void dlviz_string_free(char *s);

/**
 * Get library version string
 *
 * # Returns
 * Static version string (do not free)
 */
const char *dlviz_version(void);

/**
 * Convert a Pascal VOC bounding box back to PDF format
 *
 * # Arguments
 * - `voc`: Pascal VOC format bounding box
 * - `page_height`: Page height in points
 *
 * # Returns
 * PDF format bounding box (origin at bottom-left)
 */
struct dlviz_DlvizBBox dlviz_voc_to_bbox(struct dlviz_DlvizVocBBox voc, float page_height);

/**
 * Convert a YOLO bounding box back to PDF format
 *
 * # Arguments
 * - `yolo`: YOLO format bounding box
 * - `page_width`: Page width in points
 * - `page_height`: Page height in points
 *
 * # Returns
 * PDF format bounding box (origin at bottom-left)
 */
struct dlviz_DlvizBBox dlviz_yolo_to_bbox(struct dlviz_DlvizYoloBBox yolo,
                                          float page_width,
                                          float page_height);

#endif /* DOCLING_VIZ_BRIDGE_H */
