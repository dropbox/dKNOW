## String of columns rewriting and confluence of the jeu de ta/q.sc\_u.scin

Nohra Hage

Philippe Malbos

Abstract Schützenberger's jeu de taquin is an algorithm on the structure of tableaux, which transforms a skew tableau into a Young one by local transformation rules on the columns of the tableaux. This algorithm defines an equivalence relation on tableaux compatible with the plactic congruence, and gives a proof of the Littlewood-Richardson rule on Schur polynomials. In this article, we introduce the notion of string of columns rewriting system as mechanism of transformations of glued sequences of columns. We describe the execution of the jeu de taquin algorithm as rewriting paths of a string of columns rewriting. We deduce algebraic properties on the plactic congruence and we relate the jeu de taquin to insertion algorithms on tableaux.

Keywords Jeu de taquin, string (of columns) rewriting, Young tableaux, plactic monoids.

M.S.C. 2010 - Primary: 20M05. Secondary: 05E99, 68Q42, 20M35.

## 1. Introduction

Schützenberger introduced the jeu de taquin as an algorithm on the structure of Young tableaux to prove the Littlewood-Richardson rule on the multiplicity of a Schur polynomial in a product of Schur polynomials, namely the multiplicity of an irreducible representation of the general Lie algebra in a tensor product of two irreducible representations, [22]. The jeu de taquin has later found many applications in algebraic combinatorics and probabilistic combinatorics [4, 20, 25], and many similar algorithms were also introduced on other structures of tableaux, [9, 15, 16, 20, 23, 24].

A Young tableau is a collection of boxes in left-justified rows filled with elements of the totally ordered alphabet [ /u1D45B ] : = { 1 &lt; · · · &lt; /u1D45B } , where the entries weakly increase along each row and strictly increase down each column. A skew tableau is obtained by eliminating boxes from the rows of a Young tableau starting from top to bottom and from left to right. The eliminated boxes located above and to the left of two non-empty boxes are called inner corners of the skew tableau. We read tableaux column-wise from left to right and from bottom to top: the following tableaux

<!-- image -->

are respectively skew tableau and Young tableau whose readings are 3121312 and 3213112, and where the empty red boxes denote the inner corners. The jeu taquin consists in applying successively forward sliding operations on a skew tableau that move an inner corner into an outer position by keeping the rows weakly increasing and the columns strictly increasing, until no more inner corners remain in the initial skew tableau, as follows

<!-- image -->

<!-- image -->

Schützenberger proved remarkableproperties of the jeu de taquin on skew tableaux, [22]. He proved that the rectification of a skew tableau by the jeu de taquin is a Young tableau whose reading is equivalent to the reading of the initial skew tableau with respect the plactic congruence relation generated by the following Knuth relations , [13]:

```
/u1D467/u1D465 /u1D466.alt = /u1D465 /u1D467/u1D466.alt, for 1 /lessorequalslant /u1D465 /lessorequalslant /u1D466.alt < /u1D467 /lessorequalslant /u1D45B, and /u1D466.alt/u1D467/u1D465 = /u1D466.alt/u1D465 /u1D467, for 1 /lessorequalslant /u1D465 < /u1D466.alt /lessorequalslant /u1D467 /lessorequalslant /u1D45B .
```

/d49

This congruence defines the plactic monoid of type A , [14], which emerged from the works of Schensted [21] and Knuth [13] on the combinatorial study of Young tableaux. Plactic monoids have found several applications in algebraic combinatorics, representation theory, probabilistic combinatorics and rewriting theory, [2-4, 8, 10, 17]. Schützenberger proved that the resulting Young tableau does not depend on the order in which we choose inner corners in the forward slidings. This is the confluence property of the jeu de taquin. His proof follows the cross-section property of Young tableaux with respect the plactic congruence, proved by Knuth in [13], namely two words on [ /u1D45B ] are plactic congruent if and only if they lead to the same Young tableau after applying Schensted's insertion algorithm, [21]. Explicitly, if there are two sequences of sliding operations that transform a tableau /u1D447 into two different tableaux /u1D447 1 and /u1D447 2, then we continue applying sliding operations until we reach normal forms ˜ /u1D447 1 and ˜ /u1D447 2, that is tableaux without inner corners:

/d45

<!-- formula-not-decoded -->

/d45

/d47

/d47

˜ ˜ In this article, we introduce a machinery to prove by using a rewriting approach the confluence of the jeu de taquin. We define the sliding operations as rewriting rules on strings of columns , that is strings composed by glued sequences of columns, with a gluing map that describes the relative positions of columns. This combinatorial structure generalizes many structures of tableaux such as skew tableaux, [22], Young tableaux of type /u1D434 , [26], Young tableaux of type /u1D435 , /u1D436 , /u1D437 and /u1D43A 2, [12], quasi-ribbon tableaux, [19], and patience sorting structures [1]. In Subsection 2.2 we define a string of columns rewriting system as a binary relation on the set of strings of columns, whose rules are applied with respect to right and left positions. That is, a set of rules of the following form

/d47

/d47

/d49

˜ Since ˜ /u1D447 1 and ˜ /u1D447 2 are two Young tableaux such that their readings are plactic congruent, following the cross-section property, we deduce that /u1D447 1 = /u1D447 2 .

<!-- formula-not-decoded -->

where /u1D462, /u1D463 are strings of columns and /u1D45D /u1D460 , /u1D45E /u1D460 , /u1D45D /u1D461 , /u1D45E /u1D461 are positions in Z . In Subsection 3.2 we present the jeu de taquin by the rewriting system FS /u1D45B , whose rules are of the following form:

<!-- image -->

see Subsection 3.2.1 for detailed positions of the columns. For instance, the rectification of the above skew tableau is computed with the following reductions:

<!-- image -->

The main result of this article, Theorem 3.2.3, states that

- i) The rewriting system FS /u1D45B is confluent and terminating.
2. ii) The normal forms with respect to FS /u1D45B are Young tableaux.
3. iii) Left and right Schensted's insertion algorithms coincide with the leftmost and rightmost normalization strategies of FS /u1D45B .
4. iv) The rewriting system FS /u1D45B computes the cross-section property.

The second result of this article, Theorem 3.3.1, proves the compatibility of the rewriting system FS /u1D45B with respect the plactic congruence. Finally, from Theorems 3.2.3 and 3.3.1 we recover the cross-section property of Young tableaux with respect the plactic congruence and the commutation of right and left Schensted's insertion algorithms. In particular, we prove that the rectification map defines a surjective morphism of monoids between the sets of diagonal skew tableaux and the set of Young tableaux equipped with the corresponding insertion products.

Notations. We will consider the totally ordered set [ /u1D45B ] : = { 1 &lt; · · · &lt; /u1D45B } , for /u1D45B ∈ Z &gt; 0, as ground alphabet. We denote by [ /u1D45B ] ∗ the free monoid of words over [ /u1D45B ] , whose empty word is denoted by /u1D706 . We will denote by | /u1D464 | the length of a word /u1D464 over [ /u1D45B ] . We will denote by &lt; lex the lexicographic order on [ /u1D45B ] ∗ induced by the order on [ /u1D45B ] , and by /precedesorcurly /u1D459 /u1D452 /u1D465 and /precedesorcurly /u1D45F /u1D452 /u1D463/u1D459 /u1D452 /u1D465 the lexicographic and the reverse lexicographic order respectively on tuples of natural numbers.

## 2. String of columns rewriting

This section deals with two-dimensional strings defined by gluing columns by introducing the notion of string of columns as a generalization of the structure of Young tableaux. We define in Subsection 2.2 the notion of string of columns rewriting system as a binary relation on the set of string of columns, whose rules are applied with respect to right and left positions and we show rewriting properties on theses rewriting systems.

## 2.1. Strings of columns

2.1.1. Columns. A column ( over [ /u1D45B ] ) is a decreasing string /u1D450 /u1D458 . . . /u1D450 1 over [ /u1D45B ] , i.e. , with /u1D450 /u1D456 + 1 &gt; /u1D450 /u1D456 , for 1 /lessorequalslant /u1D456 &lt; /u1D458 . It is represented by a collection of boxes in left-justified rows, filled with elements of [ /u1D45B ] , whose each row contains only one box, and the entries strictly increase down:

/u1D450 = /u1D450 1 /u1D450 2 ...

/u1D450

/u1D458

## 2. String of columns rewriting

where 1 /lessorequalslant /u1D450 1 &lt; . . . &lt; /u1D450 /u1D458 /lessorequalslant /u1D45B , and is also denoted by ( /u1D450 1 ; . . . ; /u1D450 /u1D458 ) . Denote | /u1D450 | : = /u1D458 the length of /u1D450 . We denote by Col /u1D45B the set of columns over [ /u1D45B ] . A column of length 0 is the empty column denoted by /u1D706 /u1D450 .

- 2.1.2. String of columns. Two columns /u1D450 1 , /u1D450 2 in Col /u1D45B can be glued at position /u1D45D in Z as follows:

<!-- image -->

For 1 /lessorequalslant /u1D457 /lessorequalslant /u1D45D , we say that ( /u1D450 /u1D457 1 , /u1D450 /u1D456 + /u1D457 2 ) is a full row of length 2 in /u1D450 1 | /u1D45D /u1D450 2. A pair ( , /u1D450 /u1D457 2 ) , for 1 /lessorequalslant /u1D457 /lessorequalslant /u1D456 , and a pair ( /u1D450 /u1D457 1 , ) , for /u1D45D + 1 /lessorequalslant /u1D457 /lessorequalslant /u1D458 , is called a row of length 2, where denotes the empty box . A string of columns is a sequence of glued columns:

<!-- formula-not-decoded -->

The sequence ( /u1D45D 1 , /u1D45D 2 , . . . , /u1D45D /u1D45A ) in Z /u1D45A is called the gluing sequence of /u1D464 . Gluing sequences can be defined in a consistent way by considering a gluing map /u1D454 : Col /u1D45B × Col /u1D45B → Z that associates to columns /u1D450 and /u1D450 ′ , a gluing position /u1D454 ( /u1D450 , /u1D450 ′ ) . Given a gluing map /u1D454 , we define the set of strings of columns constructed with respect to /u1D454 as the set of string of columns of the form (2.1.3), where for any 1 /lessorequalslant /u1D456 /lessorequalslant /u1D45A , /u1D45D /u1D456 = /u1D454 ( /u1D450 /u1D456 , /u1D450 /u1D456 + 1 ) . The total length of /u1D464 is the tuple /u1D461 /u1D459 ( /u1D464 ) = (| /u1D450 1 | , . . . , | /u1D450 /u1D45A + 1 |) ∈ N /u1D45A + 1 . We will denote by | | /u1D464 | | the number of columns of /u1D464 .

For 3 /lessorequalslant /u1D458 /lessorequalslant /u1D45A + 1, a connected row of length /u1D458 is a sequence ( /u1D450 /u1D457 1 /u1D456 1 , . . . , /u1D450 /u1D457 /u1D458 /u1D456 /u1D458 ) such that ( /u1D450 /u1D457 /u1D459 /u1D456 /u1D459 , /u1D450 /u1D457 /u1D459 + 1 /u1D456 /u1D459 + 1 ) is a full row of length 2 in /u1D450 /u1D456 /u1D459 | /u1D45D /u1D456 /u1D459 /u1D450 /u1D456 /u1D459 + 1 , for 1 /lessorequalslant /u1D459 /lessorequalslant /u1D458 . Aconnected row ( /u1D450 /u1D457 1 /u1D456 1 , . . . , /u1D450 /u1D457 /u1D458 /u1D456 /u1D458 ) is increasing if /u1D450 /u1D457 1 /u1D456 1 /lessorequalslant . . . /lessorequalslant /u1D450 /u1D457 /u1D458 /u1D456 /u1D458 . We call a row ( over [ /u1D45B ] ) a string of columns whose gluing sequence is constant equal to 1 and columns are of length 1. A string of columns is row connected (resp. row increasing ) if all its rows are connected (resp. increasing).

- 2.1.4. Monoids of string of columns. We will denote by Scol /u1D45B the set of strings of columns over [ /u1D45B ] and by Scol /lessorequalslant /u1D45B the set of row connected and row increasing string of columns over [ /u1D45B ] .

Given a fixed gluing map /u1D454 , we define a concatenation operation with respect to /u1D454 by the map ·| /u1D454 · : Scol /u1D45B × Scol /u1D45B → Scol /u1D45B , by setting

<!-- formula-not-decoded -->

The operation | /u1D454 is associative and unitary, where the identity is the empty string of columns denoted by /u1D706 /u1D450 . We denote by Scol /u1D454 /u1D45B the set of string of columns in Scol /u1D45B whose gluing sequence is given by the gluing map /u1D454 . In other words, Scol /u1D454 /u1D45B is the free monoid on Col /u1D45B with respect the product | /u1D454 .

2.1.5. The four corner readings. The south-west reading is the map /u1D445 /u1D446/u1D44A : Scol /u1D45B →[ /u1D45B ] ∗ that reads a string of columns, column-wise from left to right and from bottom to top. There are three other corner readings /u1D445 /u1D441 /u1D44A , /u1D445 /u1D441 /u1D438 , /u1D445 /u1D446/u1D44A and /u1D445 /u1D446 /u1D438 defined in a similar way and that read a string of columns, column by column, with respect right or left and top or bottom directions.

Define the map Fac : [ /u1D45B ] ∗ → [ /u1D45B ] ∗ sending a word /u1D464 into the factorization /u1D464 = /u1D464 1 . . . /u1D464 /u1D458 , where each /u1D464 /u1D456 , for /u1D456 = 1 , . . . , /u1D458 , is a maximal strictly decreasing sequence, that is, the /u1D445 /u1D446/u1D44A -reading of a column in Col /u1D45B . For a fixed gluing map /u1D454 ∈ Z /u1D45B , consider the map

<!-- formula-not-decoded -->

that transforms each word /u1D464 in [ /u1D45B ] ∗ into a string of columns ( /u1D450 1 , . . . , /u1D450 /u1D458 ) where each column /u1D450 /u1D456 is filled by the elements of /u1D464 /u1D456 in Fac ( /u1D464 ) from bottom to top, for /u1D456 = 1 , . . . , /u1D458 , with respect the gluing map /u1D454 .

- 2.1.7. Properties of strings of columns. Arow connected string of columns /u1D464 as in (2.1.3) is called
- i) left-justified (resp. right-justified ) if | /u1D450 /u1D456 | /greaterorequalslant | /u1D450 /u1D456 + 1 | and | /u1D450 /u1D456 + 1 | /lessorequalslant /u1D45D /u1D456 /lessorequalslant | /u1D450 /u1D456 | (resp. | /u1D450 /u1D456 + 1 | /greaterorequalslant | /u1D450 /u1D456 | and | /u1D450 /u1D456 | /lessorequalslant /u1D45D /u1D456 /lessorequalslant | /u1D450 /u1D456 + 1 | ), for all 1 /lessorequalslant /u1D456 /lessorequalslant /u1D45A .
- ii) top-justified , (resp. bottom-justified ) if /u1D45D /u1D456 = | /u1D450 /u1D456 + 1 | (resp. /u1D45D /u1D456 = | /u1D450 /u1D456 | ), for all 1 /lessorequalslant /u1D456 /lessorequalslant /u1D45A .
- iii) decreasing (resp. increasing ) if its gluing sequence is decreasing (resp. increasing).

2.1.8. Example: skewtableaux. A skew tableau with /u1D45A + 1 columns is a string of columns /u1D450 1 | /u1D45D 1 . . . | /u1D45D /u1D45A /u1D450 /u1D45A + 1 in Scol /lessorequalslant /u1D45B , whose gluing sequence satisfies /u1D45D /u1D458 /lessorequalslant | /u1D450 /u1D458 + 1 | , for all 1 /lessorequalslant /u1D458 /lessorequalslant /u1D45A . A diagonal skew tableau is a skew tableau /u1D450 1 | /u1D45D 1 . . . | /u1D45D /u1D45A /u1D450 /u1D45A + 1 whose gluing sequence satisfies /u1D45D /u1D458 = 1, for all 1 /lessorequalslant /u1D458 /lessorequalslant /u1D45A . Wedenote by /u1D460 the gluing map for diagonal skew tableaux. We will denote by Sk /u1D45B (resp. dSk /u1D45B ) the set of skew (resp. diagonal skew) tableaux over [ /u1D45B ] . Any string /u1D462 over [ /u1D45B ] is the /u1D445 /u1D446/u1D44A -reading of a unique diagonal skew tableau, thus the map /u1D445 /u1D446/u1D44A defines a bijection from dSk /u1D45B to [ /u1D45B ] ∗ . An inner corner in a skew tableau /u1D464 is an empty box located above and to the left of two non-empty boxes. An outer corner in /u1D464 is an empty box located to the end of a row or at the bottom of a column.

We define the top (resp. bottom ) concatenation of an element /u1D465 in a column /u1D450 = ( /u1D450 1 ; . . . ; /u1D450 /u1D458 ) as the skew tableau defined by

<!-- formula-not-decoded -->

We extend these concatenations into insertion maps on skew tableaux, defined for /u1D465 ∈ [ /u1D45B ] and /u1D464 = /u1D450 1 | /u1D45D 1 . . . | /u1D45D /u1D45A /u1D450 /u1D45A in Sk /u1D45B by setting

<!-- formula-not-decoded -->

For any word /u1D464 = /u1D465 1 . . . /u1D465 /u1D458 , denote by /u1D436 /u1D451 S /u1D45F /u1D45B ( /u1D464 ) (resp. /u1D436 /u1D451 S /u1D450 /u1D45B ( /u1D464 ) ) the diagonal skew tableau obtained from /u1D464 by inserting its letters iteratively from left to right (resp. right to left) using the right (resp. left) insertion starting from the empty tableau:

<!-- formula-not-decoded -->

Define now an internal product ★ /u1D43C /u1D44E /u1D45F (resp. ★ /u1D43C /u1D44E /u1D459 ) on dSk /u1D45B by setting

<!-- formula-not-decoded -->

The top (resp. bottom) concatenation on a diagonal skew tableau /u1D464 acts only on the last (resp. first) column of /u1D464 and do not change the others columns. As a consequence, for all /u1D465 , /u1D466.alt ∈ [ /u1D45B ] , we have the following commutation property :

for all /u1D461 , /u1D461 ′ in dSk /u1D45B . By definition the relations /u1D461 ★ /u1D43C /u1D44E /u1D45F ∅ = /u1D461 (resp. /u1D461 ★ /u1D43C /u1D44E /u1D459 ∅ = /u1D461 ) and ∅ ★ /u1D43C /u1D44E /u1D45F /u1D461 = /u1D461 (resp. ∅ ★ /u1D43C /u1D44E /u1D459 /u1D461 = /u1D461 ) hold, showing that the product ★ /u1D43C /u1D44E /u1D45F (resp. ★ /u1D43C /u1D44E /u1D459 ) is unitary with respect to ∅ .

<!-- formula-not-decoded -->

Hence, we deduce that the insertion products ★ /u1D43C /u1D44E /u1D45F and ★ /u1D43C /u1D44E /u1D459 are associative.

2.1.12. Example: Young tableaux. A Young tableau with /u1D45A + 1 columns is a string of columns /u1D450 1 | /u1D45D 1 . . . | /u1D45D /u1D45A /u1D450 /u1D45A + 1 in Scol /lessorequalslant /u1D45B whose gluing sequence is decreasing and satisfies

<!-- formula-not-decoded -->

We denote by Y the gluing map for Young tableaux, and by Yt /u1D45B the set of Young tableaux over [ /u1D45B ] .

Given a row /u1D45F (resp. a column /u1D450 ), we denote by RowInsert ( /u1D45F , /u1D465 ) (resp. ColumnInsert ( /u1D450 , /u1D465 ) ) the procedure that inserts an element /u1D465 in a row /u1D45F (resp. column /u1D450 ) and returns a pair ( /u1D45F ′ , /u1D466.alt ) (resp. ( /u1D450 ′ , /u1D466.alt ) ) made of the resulting row /u1D45F ′ (resp. column /u1D450 ′ ) and the bumping element /u1D466.alt that can be empty, as follows. If /u1D465 is bigger or equal (resp. strictly bigger) than all the elements of /u1D45F (resp. /u1D450 ), then /u1D45F ′ (resp. /u1D450 ′ ) is obtained by adding /u1D465 to the end (resp. the bottom) of /u1D45F (resp. /u1D450 ) and /u1D466.alt is empty. Otherwise, let /u1D466.alt be the smallest element of /u1D45F (resp. /u1D450 ) such that /u1D465 &lt; /u1D466.alt (resp. /u1D465 /lessorequalslant /u1D466.alt ), then /u1D45F ′ (resp. /u1D450 ′ ) is obtained from /u1D45F (resp. /u1D450 ) by replacing /u1D466.alt by /u1D465 . The right (resp. left ) insertion algorithm computes a tableau ( /u1D461 /squiggleright /u1D446 /u1D45F /u1D465 ) (resp. ( /u1D465 /squiggleright /u1D446 /u1D459 /u1D461 ) ) as follows,[21]:

```
RightInsertYT ( /u1D461 , /u1D465 ) Input: A Young tableau /u1D461 and /u1D465 in [ /u1D45B ] . Output: The Young tableau ( /u1D461 /squiggleright /u1D446 /u1D45F /u1D465 ) . /u1D466.alt : = /u1D465 ; /u1D461 ′ : = ∅ ; while /u1D466.alt ≠ /u1D706 do /u1D45F : = /u1D461 [ 1 ] ; /u1D461 : = /u1D461 / /u1D45F ; ( /u1D45F ′ , /u1D466.alt ) : = RowInsert ( /u1D45F , /u1D466.alt ) /u1D461 ′ : = ( /u1D461 ′ ; /u1D45F ′ ) end return ( /u1D461 ′ ; /u1D461 )
```

Algorithm 1: Schensted's right algorithm

```
LeftInsertYT ( /u1D461 , /u1D465 ) Input: A Young tableau /u1D461 and /u1D465 in [ /u1D45B ] . Output: The Young tableau ( /u1D465 /squiggleright /u1D446 /u1D459 /u1D461 ) /u1D466.alt : = /u1D465 ; /u1D461 ′ : = ∅ ; while /u1D466.alt ≠ /u1D706 do /u1D450 : = /u1D461 [ 1 ] ; /u1D461 : = /u1D461 / /u1D450 ; ( /u1D450 ′ , /u1D466.alt ) : = ColumnInsert ( /u1D450 , /u1D466.alt ) /u1D461 ′ : = [ /u1D461 ′ ; /u1D450 ′ ] end return [ /u1D461 ′ ; /u1D461 ]
```

Algorithm 2: Schensted's left algorithm

```
.
```

where /u1D461 [ /u1D456 ] (resp. /u1D461 [ /u1D456 ] ) denotes the /u1D456 -th row (resp. column) of the tableau /u1D461 , and /u1D461 / /u1D461 [ 1 ] (resp. /u1D461 / /u1D461 [ 1 ] ) the Young tableau obtained from /u1D461 by removing its first row (resp. column), and where ( /u1D461 ; /u1D461 ′ ) (resp. [ /u1D461 ; /u1D461 ′ ] ) denotes the Young tableau obtained by concatenating /u1D461 over (resp. to the right of) a Young tableau /u1D461 ′ when the concatenation defines a Young tableau.

For any word /u1D464 = /u1D465 1 . . . /u1D465 /u1D458 , denote by /u1D436 Y /u1D45F /u1D45B ( /u1D464 ) (resp. /u1D436 Y /u1D450 /u1D45B ( /u1D464 ) ) the Young tableau obtained from /u1D464 by inserting its letters iteratively from left to right (resp. right to left) using the right (resp. left) insertion starting from the empty tableau:

<!-- formula-not-decoded -->

Define now an internal product ★ /u1D446 /u1D45F (resp. ★ /u1D446 /u1D459 ) on Yt /u1D45B by setting

<!-- formula-not-decoded -->

for all /u1D461 , /u1D461 ′ in Yt /u1D45B . By definition the relations /u1D461 ★ /u1D446 /u1D45F ∅ = /u1D461 (resp. /u1D461 ★ /u1D446 /u1D459 ∅ = /u1D461 ) and ∅ ★ /u1D446 /u1D45F /u1D461 = /u1D461 (resp. ∅ ★ /u1D446 /u1D459 /u1D461 = /u1D461 ) hold, showing that the product ★ /u1D446 /u1D45F (resp. ★ /u1D446 /u1D459 ) is unitary with respect to ∅ .

Let /u1D450 be a column of length /u1D45D , the Schützenberger involution of /u1D450 , denoted by /u1D450 ∗ , is the column of length /u1D45B -/u1D45D obtained by taking the complement of the elements of /u1D450 . This involution is extended to string of columns by setting ( /u1D450 1 | . . . | /u1D450 /u1D45F ) ∗ = /u1D450 ∗ /u1D45F | . . . | /u1D450 ∗ 1 , for all /u1D450 1 , . . . , /u1D450 /u1D45F in Col /u1D45B . If /u1D450 1 |Y . . . |Y /u1D450 /u1D45F is a Young tableau, then ( /u1D450 1 |Y . . . |Y /u1D450 /u1D45F ) ∗ = /u1D450 ∗ /u1D45F |Y . . . |Y /u1D450 ∗ 1 is also a Young tableau. Moreover, the following equality ( /u1D450 1 ★ /u1D446 /u1D45F . . . ★ /u1D446 /u1D45F /u1D450 /u1D45F ) ∗ = ( /u1D450 ∗ /u1D45F ★ /u1D446 /u1D45F . . . ★ /u1D446 /u1D45F /u1D450 ∗ 1 ) holds, for all /u1D450 1 , . . . , /u1D450 /u1D45F in Col /u1D45B . In particular, for three columns /u1D450 /u1D456 , /u1D450 /u1D457 and /u1D450 /u1D458 in Col /u1D45B , we have ( /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 ★ /u1D446 /u1D45F /u1D450 /u1D458 ) ∗ = ( /u1D450 ∗ /u1D458 ★ /u1D446 /u1D45F /u1D450 ∗ /u1D457 ★ /u1D446 /u1D45F /u1D450 ∗ /u1D456 ) , see [10, Remark 3.2.7].

## 2.2. String of columns rewriting

2.2.1. Rewriting steps. Let define Scol P /u1D45B = Z × Scol /u1D45B × Z , whose elements are triples ( /u1D45D , /u1D462, /u1D45E ) where /u1D45D , /u1D45E are positions in Z and /u1D462 is a string of columns, that we will denote by | /u1D45D /u1D462 | /u1D45E . Wedefine a string of columns rewriting system , called rewriting system for short in the sequel, as a binary relation on Scol P /u1D45B . That is, a set of rules of the form

<!-- formula-not-decoded -->

where /u1D462, /u1D463 are strings of columns in Scol /u1D45B and /u1D45D /u1D460 , /u1D45E /u1D460 , /u1D45D /u1D461 , /u1D45E /u1D461 are positions in Z . Thepair ( /u1D45D /u1D460 , /u1D45E /u1D460 ) (resp. ( /u1D45D /u1D461 , /u1D45E /u1D461 ) ) is called the source (resp. target ) positions , and /u1D462 (resp. /u1D463 ) is called the string of columns source (resp. target ) of the rule /u1D6FC , denoted by /u1D460 ( /u1D6FC ) (resp. /u1D461 ( /u1D6FC ) ).

A string of columns /u1D464 is said to be reducible with respect to /u1D6FC , if there is a factorization /u1D464 = /u1D464 1 | /u1D45D /u1D460 /u1D460 ( /u1D6FC )| /u1D45E /u1D460 /u1D464 2 in Scol /u1D45B . In that case, /u1D464 reduces into /u1D464 ′ = /u1D464 1 | /u1D45D /u1D461 /u1D461 ( /u1D6FC )| /u1D45E /u1D461 /u1D464 2. Such a reduction is denoted by /u1D464 1 | /u1D45D /u1D460 /u1D6FC | /u1D45E /u1D460 /u1D464 2 , or /u1D6FC if there is no possible confusion. Given a rewriting system R , the set of all reductions defines a binary relation on Scol /u1D45B , called the R -rewrite relation that we will denote by ⇒R , or ⇒ if there is no possible confusion. The elements of ⇒R are called R -rewriting steps , and have the form

<!-- formula-not-decoded -->

for all /u1D6FC in R and /u1D464 1 , /u1D464 2 in Scol /u1D45B . In (2.2.3) the data | /u1D45D 1 /u1D464 1 | /u1D45D /u1D460 - | /u1D45E /u1D460 /u1D464 2 | /u1D45D 2 is called the context of the rule /u1D6FC . If we denote by /u1D436 this context, the reduction (2.2.3) can be also denoted by /u1D436 [ /u1D6FC ] .

Wedenote by ⇒ ∗ R the reflexive and transitive closure of the relation ⇒R , whose elements are called R -rewriting paths .

2.2.4. Rewriting properties. A rewriting system R is terminating if there is no infinite R -rewriting path. A local branching (resp. branching ) of R is a pair ( /u1D711 , /u1D713 ) of R -rewriting steps (resp. R -rewriting paths) having the same source as depicted in the following reduction diagram:

/d38

/d58

<!-- image -->

/d36

/d56

Such a branching is confluent if there exist R -rewriting paths /u1D711 ′ and /u1D713 ′ with a common target as follows:

/d38

/d58

<!-- image -->

/d36

/d56

We say that R is locally confluent (resp. confluent ) if any local branching (resp. branching) of R is confluent, and that R is convergent if it is confluent and terminating. A string of columns /u1D464 is in normal form with respect to R , if there is no rule that reduces /u1D464 . When R is convergent, any string of columns /u1D464 has a unique normal form, denoted by Nf ( /u1D464 , R) .

2.2.6. Critical branching. A local branching of the form ( /u1D711 , /u1D711 ) is called aspherical . A local branching ( /u1D711 , /u1D713 ) is called orthogonal if the source of /u1D711 does not overlap with the source of /u1D713 , that is the source of the branching is of the form | /u1D45D 0 /u1D464 1 | /u1D45D 1 /u1D460 ( /u1D711 )| /u1D45E 1 /u1D464 2 | /u1D45D 2 /u1D460 ( /u1D713 )| /u1D45E 2 /u1D464 3 | /u1D45D 3 , with /u1D464 1 , /u1D464 2 , /u1D464 3 in Scol /u1D45B . Alocal branching that is neither aspherical nor orthogonal is called overlapping . There are three shapes of overlapping branchings ( /u1D711 , /u1D713 ) , where /u1D460 ( /u1D711 ) = | /u1D45D 0 /u1D464 1 | /u1D45D /u1D460 /u1D460 ( /u1D6FC )| /u1D45E /u1D460 /u1D464 2 | /u1D45D 2 , and /u1D460 ( /u1D713 ) = | /u1D45D ′ 0 /u1D464 ′ 1 | /u1D45D ′ /u1D460 /u1D460 ( /u1D6FD )| /u1D45E ′ /u1D460 /u1D464 ′ 2 | /u1D45D ′ 2 , with /u1D6FC , /u1D6FD ∈ R , described by the following situations:

- i) ( position overlapping ) /u1D45E /u1D460 = /u1D45E ′ /u1D460 ,
2. ii) ( string overlapping ) /u1D460 ( /u1D6FC ) = | /u1D45D /u1D460 /u1D462 /u1D6FC | /u1D45D ′ /u1D460 /u1D463 /u1D6FC | /u1D45E /u1D460 and /u1D460 ( /u1D6FD ) = | /u1D45D ′ /u1D460 /u1D463 /u1D6FC | /u1D45E /u1D460 /u1D462 /u1D6FD | /u1D45E ′ /u1D460 ,
3. iii) ( inclusion ) /u1D460 ( /u1D6FD ) = | /u1D45D ′ /u1D460 /u1D462 /u1D6FD | /u1D45D /u1D460 /u1D460 ( /u1D6FC )| /u1D45E /u1D460 /u1D463 /u1D6FD | /u1D45E ′ /u1D460 .

An overlapping branching that is minimal for the relation /subsetsqequal on branchings generated by

/d40

/d40

/d60

,

<!-- image -->

/d34

/d54

/d34

/d54

for any branching ( /u1D711 , /u1D713 ) and context /u1D462 | /u1D45D - | /u1D45E /u1D463 of reductions /u1D711 , /u1D713 , is called a critical branching .

2.2.7. Lemma. A rewriting system R is locally confluent if and only if all its critical branchings are confluent. Moreover, if R is terminating with all its critical branchings are confluent, then it is confluent.

/d60

/d49

/d69

/d24

/d44

Proof. The first statement is the critical branching lemma. Suppose that all the critical branchings of R are confluent and prove that any local branching of R is confluent. By definition, every aspherical branching is trivially confluent, and every orthogonal local branching is confluent. Consider an overlapping but not minimal local branching ( /u1D711 , /u1D713 ) , there exist factorizations /u1D711 = /u1D436 [ /u1D711 ′ ] and /u1D713 = /u1D436 [ /u1D713 ′ ] , where ( /u1D711 ′ , /u1D713 ′ ) is a critical branching of R . By hypothesis, this branching is confluent, and there are reductions paths /u1D711 ′′ : /u1D461 ( /u1D711 ′ ) → /u1D464 and /u1D713 ′′ : /u1D461 ( /u1D713 ′ ) → /u1D464 that reduce targets of /u1D711 ′ and /u1D713 ′ to the same string of columns /u1D464 . It follows that the reductions paths /u1D436 [ /u1D711 ′′ ] and /u1D436 [ /u1D713 ′′ ] make the branching ( /u1D711 , /u1D713 ) confluent.

The second statement is an immediate consequence of Newman's lemma, [18], that proves that any locally confluent terminating rewriting system is confluent. /square

2.2.8. Normalization strategies. A reduction strategy for a rewriting system R specifies a way to apply the rules in a deterministic way. When R is normalizing, a normalization strategy is a mapping /u1D70E of every string of columns | /u1D45D /u1D464 | /u1D45E to a rewriting path /u1D70E | /u1D45D /u1D464 | /u1D45E with source | /u1D45D /u1D464 | /u1D45E and target a chosen normal form of | /u1D45D /u1D464 | /u1D45E with respect to R . For a reduced rewriting system, we distinguish the leftmost reduction strategy and the rightmost one, according to the way we apply first the rewriting rule that reduces the leftmost or the rightmost string of columns. They are defined as follows. For every string of columns | /u1D45D /u1D464 | /u1D45E , the set of rewriting steps with source | /u1D45D /u1D464 | /u1D45E can be ordered from left to right by setting /u1D711 ≺ /u1D713 , for rewriting steps /u1D711 = | /u1D45D /u1D464 1 | /u1D45D /u1D460 /u1D6FC | /u1D45E /u1D460 /u1D464 2 | /u1D45E and /u1D711 = | /u1D45D /u1D464 ′ 1 | /u1D45D /u1D460 /u1D6FD | /u1D45E /u1D460 /u1D464 ′ 2 | /u1D45E such that | | /u1D464 1 | | &lt; | | /u1D464 ′ 1 | | . If R is finite, then the order ≺ is total and the set of rewriting steps of source | /u1D45D /u1D464 | /u1D45E is finite. Hence this set contains a smallest element /u1D70E | /u1D45D /u1D464 | /u1D45E and a greatest element /u1D702 | /u1D45D /u1D464 | /u1D45E , respectively called the leftmost and the rightmost rewriting steps on | /u1D45D /u1D464 | /u1D45E . If, moreover, the rewriting system terminates, the iteration of /u1D70E (resp. /u1D702 ) yields a normalization strategy for R called the leftmost (resp. rightmost ) normalization strategy of R :

<!-- formula-not-decoded -->

The leftmost (resp. rightmost ) rewriting path on a string of columns | /u1D45D /u1D464 | /u1D45E is the rewriting path obtained by applying the leftmost (resp. rightmost) normalization strategy /u1D70C /latticetop R (resp. /u1D70C ⊥ R ). We refer the reader to [6] and [7] for more details on rewriting normalization strategies.

2.2.9. Top-left sliding order. Awaytoproveterminationofa string of columns rewriting system R is to consider a map /u1D453 : Scol /u1D45B →( /u1D44B , ≺) , where ( /u1D44B , ≺) is a well-ordered set satisfying, for all /u1D464 , /u1D464 ′ ∈ Scol /u1D45B ,

<!-- formula-not-decoded -->

We will use the following termination order. Let /u1D464 = /u1D462 1 | /u1D45D 1 . . . | /u1D45D /u1D45A -1 /u1D462 /u1D45A be in Scol /u1D45B . Denote by ℎ /u1D462 /u1D458 the number of empty boxes between the top box of the column /u1D462 /u1D458 and the top position of /u1D464 , shown by the blue line in the following picture

<!-- image -->

## 3. Convergence of the jeu de taquin

Define the top deviation of /u1D464 as the sequence /u1D451 /latticetop ( /u1D464 ) = ( ℎ /u1D462 1 , . . . , ℎ /u1D462 /u1D45A ) ∈ N /u1D45A . Denote by /precedesequal /u1D459 /u1D452 /u1D465 the total order on Scol /u1D45B defined by /u1D464 /precedesequal /u1D459 /u1D452 /u1D465 /u1D464 ′ if and only if

<!-- formula-not-decoded -->

In order to prove the termination of top-left sliding operations presented in 3.2.1, we define the total order /lessmuch /u1D461 /u1D459 on Scol /u1D45B by setting, for /u1D464 , /u1D464 ′ in Scol /u1D45B , /u1D464 /lessmuch /u1D461 /u1D459 /u1D464 ′ if and only if

<!-- formula-not-decoded -->

## 3. Convergence of the jeu de ta/q.sc\_u.scin

In this section, we study the confluence of the jeu de taquin through a rewriting system defined by column slidings. We show that this rewriting system is convergent and we present the jeu de taquin as a surjective map from the set of diagonal skew tableaux to the set of Young tableaux using insertion. We recover properties relating the jeu de taquin to the plactic congruence and insertion algorithms on the structure of Young tableaux.

## 3.1. Jeu de taquin

3.1.1. Plactic monoids. Recall that the plactic monoid (of type /u1D434 ) of rank /u1D45B , introduced in [14], and denoted by P /u1D45B , is generated on [ /u1D45B ] and submitted to the following Knuth relations , [13]:

<!-- formula-not-decoded -->

Knuth in [13] described the congruence ≈ P /u1D45B generated by these relations in terms of Young tableaux and proved the cross-section property for the monoid P /u1D45B .

- 3.1.3. Forward sliding, [22]. A forward sliding is a sequence of the following slidings:

<!-- image -->

starting from a skew tableau and one of its inner corners, and moving the empty box until it becomes an outer corner. The jeu de taquin on a skew tableau /u1D464 consists in applying successively the forward slide algorithm starting from /u1D464 until we get a string of columns without inner corners denoted /u1D70B /u1D461 /u1D45E ( /u1D464 ) , which is shown to be a Young tableau. In this way, the jeu de taquin defines a map

<!-- formula-not-decoded -->

also called the rectification of skew tableaux. Schützenberger proved in [22] many properties of the jeu de taquin. These properties are also presented by Fulton in [4], as follows. For any /u1D464 ∈ Sk /u1D45B , the following conditions hold

- i) [4, Proposition 2]. /u1D445 /u1D446/u1D44A ( /u1D464 ) ≈ P /u1D45B /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D464 )) ,
2. ii) [4, Corollary 1]. The rectification /u1D70B /u1D461 /u1D45E ( /u1D464 ) is the unique Young tableau satisfying i) ,

- iii) [4, Claim 2]. The map /u1D70B /u1D461 /u1D45E does not depend on the order in which the inner corners are chosen.

Note that condition ii) is a consequence of the cross-section property for P /u1D45B proved in [13] and condition i) . Moreover, condition iii) is a consequence of conditions i) and ii) . In the rest of this section, weshow that conditions i) and ii) are direct consequence of a confluence property of a rewriting system that computes the map /u1D70B /u1D461 /u1D45E , and without supposing the cross-section property for P /u1D45B which will be also consequence of this confluence property.

- 3.1.4. Example. The jeu de taquin on the following skew tableau /u1D464 starting with the inner corner applies three occurrences of forward sliding, where denotes the empty box, and the outer corner:

<!-- image -->

## 3.2. Jeu de taquin as rewriting

- 3.2.1. Rules of the jeu de taquin. The jeu de taquin map /u1D70B /u1D461 /u1D45E is described by the union of rewriting systems FS /u1D45B = LS /u1D45B ∪ IS /u1D45B ∪ TS /u1D45B whose sets of rules are defined as follows.
- i) LS /u1D45B the set of left-sliding rules that move sub-columns to the left in the following two situations:

<!-- image -->

## 3. Convergence of the jeu de taquin

<!-- image -->

such that /u1D450 /u1D456 | ( + -) /u1D450 /u1D457 ∉ Scol /lessorequalslant , and /u1D45A is maximal such that /u1D450 /u1D456 | ( + -) /u1D450 /u1D457 ∈ Scol /lessorequalslant and /u1D456 1 /lessorequalslant /u1D45D .

## ii) IS

/u1D456 1 /u1D456 2 /u1D45E /u1D45B /u1D456 1 /u1D456 2 /u1D45D /u1D45B /u1D45B is the set of insert-sliding rules performing insertion in the following two situations:

<!-- image -->

that /u1D450 /u1D456 | /u1D458 /u1D450 /u1D457 ∈ Scol /lessorequalslant /u1D45B with 1 /lessorequalslant /u1D458 /lessorequalslant /u1D456 1 and /u1D458 &lt; /u1D456 2, and /u1D459 is minimal such that ( /u1D450 /u1D459 /u1D456 , /u1D450 /u1D45A + 1 /u1D457 ) is a row and /u1D450 /u1D459 -1 /u1D456 &lt; /u1D450 /u1D45A /u1D457 &lt; /u1D450 /u1D459 /u1D456 .

<!-- image -->

tions /u1D45D ′ , /u1D45E ′ , such that /u1D450 /u1D456 | ( /u1D456 1 + /u1D456 2 -/u1D45E ) /u1D450 /u1D457 ∉ Scol /lessorequalslant /u1D45B , where /u1D45D is maximal such that /u1D450 /u1D456 | /u1D45D /u1D450 /u1D457 ∈ Scol /lessorequalslant /u1D45B , and /u1D45B is minimal such that ( /u1D450 /u1D45B /u1D456 , /u1D450 /u1D461 + 1 /u1D457 ) is a row with /u1D450 /u1D45B -1 /u1D456 &lt; /u1D450 /u1D461 /u1D457 &lt; /u1D450 /u1D45B /u1D456 .

- iii) TS /u1D45B is the set of left top sliding rules that move columns to the top as follows:

<!-- image -->

indexed by columns /u1D450 /u1D456 , /u1D450 /u1D457 and positions /u1D45D ′ , /u1D45E ′ , such that /u1D450 /u1D456 | /u1D45F /u1D450 /u1D457 ∈ Scol /lessorequalslant /u1D45B with 1 /lessorequalslant /u1D45F &lt; /u1D456 2 , or /u1D450 /u1D456 | /u1D45F /u1D450 /u1D457 is not row connected with /u1D450 1 /u1D456 /lessorequalslant /u1D450 /u1D456 2 /u1D457 , and /u1D460 is maximal such that /u1D450 /u1D456 | /u1D460 /u1D450 /u1D457 ∈ Scol /lessorequalslant /u1D45B and /u1D460 /lessorequalslant /u1D456 2 .

<!-- image -->

such that /u1D450 /u1D456 | ( /u1D456 1 + /u1D456 2 -/u1D45D ) /u1D450 /u1D457 ∉ Scol /lessorequalslant /u1D45B and /u1D450 /u1D456 | /u1D456 2 /u1D450 /u1D457 ∈ Scol /lessorequalslant /u1D45B , or /u1D450 /u1D456 | ( /u1D456 1 + /u1D456 2 -/u1D45D ) /u1D450 /u1D457 ∈ Scol /lessorequalslant /u1D45B and /u1D456 1 &gt; /u1D45D , or /u1D450 /u1D456 | /u1D458 /u1D450 /u1D457 is not row connected with /u1D458 &gt; /u1D456 1 and /u1D450 /u1D456 1 /u1D456 /lessorequalslant /u1D450 1 /u1D457 .

In the sequel, if there is no possible confusion, we will omit the subscripts /u1D450 /u1D456 , /u1D450 /u1D457 in the notation of the rules. Moreover, for any rule /u1D707 in FS /u1D45B , we will denote by /u1D707 ∗ any composition of rewriting sequences involving the rules /u1D707 and ending on a normal form with respect to /u1D707 .

- 3.2.2. Example. The rectification of the skew tableau /u1D464 from Example 3.1.4 is computed with the following reduction of FS /u1D45B :
- 3.2.3. Theorem. The rewriting system FS /u1D45B satisfies the following conditions:
- i) FS /u1D45B is convergent.
- ii) The normal form of any skew tableau with respect to FS /u1D45B is a Young tableau.

<!-- image -->

## 3. Convergence of the jeu de taquin

For every word /u1D464 in [ /u1D45B ] ∗ , we have

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

The rest of this subsection is devoted to the proof of this result. Lemmata 3.2.8 and 3.2.9 show that the rewriting system FS /u1D45B is convergent. As a consequence, we obtain that the normal forms are Young tableaux. We prove in 3.2.6 that right and left Schensted's insertion algorithm coincide respectively with the leftmost and rightmost normalization strategy of FS /u1D45B . Condition iii) and convergence of FS /u1D45B yield Condition iv) .

3.2.4. Lemma. For any rule | /u1D450 /u1D456 1 | /u1D450 /u1D456 2 | ⇒| /u1D450 /u1D457 1 | /u1D450 /u1D457 2 | in FS /u1D45B , the following equality | /u1D450 /u1D456 1 ★ /u1D446 /u1D45F /u1D450 /u1D456 2 | = /u1D70C /latticetop FS /u1D45B (| /u1D450 /u1D457 1 | /u1D450 /u1D457 2 |) holds. Moreover, for all /u1D450 /u1D456 = ( /u1D450 1 /u1D456 , . . . , /u1D450 /u1D456 1 /u1D456 ) and /u1D450 /u1D457 = ( /u1D450 1 /u1D457 , . . . , /u1D450 /u1D456 2 /u1D457 ) in Col /u1D45B , we have

<!-- formula-not-decoded -->

Proof. Prove that for any rule | /u1D450 /u1D456 1 | /u1D450 /u1D456 2 | ⇒ | /u1D450 /u1D457 1 | /u1D450 /u1D457 2 | in FS /u1D45B , we have | /u1D450 /u1D456 1 ★ /u1D446 /u1D45F /u1D450 /u1D456 2 | = /u1D70C /latticetop FS /u1D45B (| /u1D450 /u1D457 1 | /u1D450 /u1D457 2 |) . The rules /u1D6FC /u1D450 /u1D456 ,/u1D450 /u1D457 , /u1D6FF /u1D6FC /u1D450 /u1D456 ,/u1D450 /u1D457 , /u1D6FD /u1D450 /u1D456 ,/u1D450 /u1D457 and /u1D6FF /u1D6FD /u1D450 /u1D456 ,/u1D450 /u1D457 followed by /u1D6FD ∗ yield to the Young tableau | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 | . Consider now the rule /u1D6FE /u1D450 /u1D456 ,/u1D450 /u1D457 . If | /u1D450 /u1D457 | /lessorequalslant | /u1D450 /u1D456 | and /u1D450 /u1D456 | | /u1D450 /u1D457 | /u1D450 /u1D457 ∈ Scol /u1D45B then the target of /u1D6FE /u1D450 /u1D456 ,/u1D450 /u1D457 is equal to | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 | . If | /u1D450 /u1D456 | &lt; | /u1D450 /u1D457 | and /u1D450 /u1D456 | | /u1D450 /u1D457 | /u1D450 /u1D457 ∈ Scol /u1D45B , then the rule /u1D6FE /u1D450 /u1D456 ,/u1D450 /u1D457 is followed by the rule /u1D6FC /u1D450 /u1D456 ,/u1D450 /u1D457 in order to obtain | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 | . If /u1D450 /u1D456 | | /u1D450 /u1D457 | /u1D450 /u1D457 ∉ Scol /u1D45B then the rule /u1D6FE /u1D450 /u1D456 ,/u1D450 /u1D457 followed by /u1D6FC /u1D450 /u1D456 ,/u1D450 /u1D457 and then by /u1D6FD ∗ , or only followed by /u1D6FD ∗ yield to | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 | . Consider finally the rule /u1D6FF /u1D450 /u1D456 ,/u1D450 /u1D457 . If | /u1D450 /u1D457 | /lessorequalslant | /u1D450 /u1D456 | then the target /u1D6FF /u1D450 /u1D456 ,/u1D450 /u1D457 is equal to | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 | . Otherwise, if | /u1D450 /u1D456 | &lt; | /u1D450 /u1D457 | then /u1D6FF /u1D450 /u1D456 ,/u1D450 /u1D457 is followed by /u1D6FC /u1D450 /u1D456 ,/u1D450 /u1D457 in order to obtain | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 | .

Prove the first equality of (3.2.5) by induction on | /u1D450 /u1D457 | , the proof being similar for ★ /u1D446 /u1D459 . Suppose that | /u1D450 /u1D457 | = 1, we consider the following two cases. If /u1D450 1 /u1D456 /lessorequalslant /u1D450 1 /u1D457 , then /u1D450 /u1D456 | 1 /u1D450 /u1D457 is equal to /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 . If /u1D450 1 /u1D457 &lt; /u1D450 1 /u1D456 , then by applying /u1D6FF /u1D6FD on /u1D450 /u1D456 | 1 /u1D450 /u1D457 we obtain /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 . Suppose the equality holds when | /u1D450 /u1D457 | = /u1D456 2 -1, and prove it when | /u1D450 /u1D457 | = /u1D456 2. First consider the case when /u1D450 1 /u1D456 /lessorequalslant /u1D450 /u1D456 2 /u1D457 . Suppose that by induction we have

<!-- image -->

where /u1D465 /u1D456 and /u1D466.alt /u1D457 are elements of /u1D450 /u1D456 and /u1D450 /u1D457 with /u1D461 /lessorequalslant /u1D460 . We prove that /u1D70C /latticetop FS /u1D45B (

considering the following two cases.

<!-- image -->

Case 1. /u1D465 1 /lessorequalslant /u1D450 1 /u1D457 and /u1D465 /u1D458 + 1 /lessorequalslant /u1D466.alt /u1D458 , for all /u1D458 = 1 , . . . , /u1D461 -1:

<!-- image -->

Case 2. /u1D465 1 /lessorequalslant /u1D450 1 /u1D457 (resp. /u1D450 1 /u1D457 &lt; /u1D465 1 ) and let /u1D465 /u1D456 be minimal such that /u1D465 /u1D456 -1 &lt; /u1D466.alt /u1D456 -1 &lt; /u1D465 /u1D456 :

3.2.6. Proof of Theorem 3.2.3 iii). Weprove the first equality by induction on the number of columns in [ /u1D464 ] /u1D460 , the proof being similar for the insertion /u1D446 /u1D459 . When [ /u1D464 ] /u1D460 is of length 2, then the equality is a consequence of Lemma 3.2.4. For /u1D458 /greaterorequalslant 3, suppose that the equality holds for words of length /u1D458 -1, and consider [ /u1D464 ] /u1D460 = /u1D450 1 | 1 . . . | 1 /u1D450 /u1D458 . By the induction hypothesis, we have (∅ /squiggleright /u1D446 /u1D45F /u1D464 ) = /u1D70C /latticetop FS /u1D45B ( /u1D450 1 | 1 . . . | 1 /u1D450 /u1D458 -1 ) ★ /u1D446 /u1D45F /u1D450 /u1D458 . Let us show that

<!-- image -->

<!-- formula-not-decoded -->

Since inserting /u1D450 /u1D458 into /u1D70C /latticetop FS /u1D45B ( /u1D450 1 | 1 . . . | 1 /u1D450 /u1D458 -1 ) consists into inserting its elements one by one from bottom to top, it suffices to prove (3.2.7) for /u1D450 /u1D458 = ( /u1D465 ) . If /u1D465 is bigger or equal than the last element /u1D465 /u1D456 1 1 of

## 3. Convergence of the jeu de taquin

the first row of /u1D70C /latticetop FS /u1D45B ( /u1D450 1 | 1 . . . | 1 /u1D450 /u1D458 -1 ) , then /u1D70C /latticetop FS /u1D45B ( /u1D450 1 | 1 . . . | 1 /u1D450 /u1D458 -1 )| 1 /u1D465 is a Young tableau which is equal to /u1D70C /latticetop FS /u1D45B ( /u1D450 1 | 1 . . . | 1 /u1D450 /u1D458 -1 ) ★ /u1D446 /u1D45F /u1D465 . Otherwise, if /u1D465 &lt; /u1D465 /u1D456 1 1 , we first apply a rule /u1D6FF /u1D6FD in order to slide the box containing /u1D465 to the top of the one containing /u1D465 /u1D456 1 1 . Wethen apply the following reduction rules as shown in the following reduction diagrams. Note that, the elements in the colored boxes represent the ones that are bumped when inserting /u1D465 into the tableau /u1D70C /latticetop FS /u1D45B ( /u1D450 1 | 1 . . . | 1 /u1D450 /u1D458 -1 ) .

=

<!-- image -->

The resulted Young tableau is equal to /u1D70C /latticetop FS /u1D45B ( /u1D450 1 | 1 . . . | 1 /u1D450 /u1D458 -1 ) ★ /u1D446 /u1D45F /u1D465 , showing the claim.

3.2.8. Lemma. The rewriting system FS /u1D45B is terminating.

Proof. We prove that for any reduction /u1D464 ⇒ /u1D464 ′ with respect to FS /u1D45B , we have /u1D464 /lessmuch /u1D461 /u1D459 /u1D464 ′ for the order /lessmuch /u1D461 /u1D459 defined 2.2.9. If /u1D464 ⇒ /u1D464 ′ is a reduction with respect to LS /u1D45B , then | | /u1D464 | | = | | /u1D464 ′ | | and /u1D461 /u1D459 ( /u1D464 ) ≺ /u1D45F /u1D452 /u1D463/u1D459 /u1D452 /u1D465 /u1D461 /u1D459 ( /u1D464 ′ ) , showing that /u1D464 /lessmuch /u1D461 /u1D459 /u1D464 ′ . Suppose now that the reduction is with respect to IS /u1D45B . There are two cases depending on the number of columns in the targets of the rules /u1D6FD and /u1D6FF /u1D6FD . If the targets consist only of one column then | | /u1D464 | | &lt; | | /u1D464 ′ | | . If they consist of two columns then | | /u1D464 | | = | | /u1D464 ′ | | and /u1D461 /u1D459 ( /u1D464 ) ≺ /u1D45F /u1D452 /u1D463/u1D459 /u1D452 /u1D465 /u1D461 /u1D459 ( /u1D464 ′ ) . Then, if /u1D464 ⇒ /u1D464 ′ is a reduction with respect to IS /u1D45B , we obtain /u1D464 /lessmuch /u1D461 /u1D459 /u1D464 ′ . Finally, for any reduction /u1D464 ⇒ /u1D464 ′ with respect to TS /u1D45B , we have | | /u1D464 | | = | | /u1D464 ′ | | , /u1D461 /u1D459 ( /u1D464 ) = /u1D461 /u1D459 ( /u1D464 ′ ) and /u1D451 /latticetop ( /u1D464 ) ≺ /u1D459 /u1D452 /u1D465 /u1D451 /latticetop ( /u1D464 ′ ) , showing that /u1D464 /lessmuch /u1D461 /u1D459 /u1D464 ′ . /square

## 3.2.9. Lemma. The rewriting system FS /u1D45B is confluent.

Proof. Following Lemma 2.2.7, we prove that the rewriting system FS /u1D45B is confluent by showing the confluence of all its critical branchings. Consider first the rewriting system R( Col /u1D45B , Y /u1D45F /u1D45B ) whose rules are of the form /u1D6FE /u1D450 , /u1D450 ′ : | /u1D450 | /u1D450 ′ | ⇒| /u1D450 ★ /u1D446 /u1D45F /u1D450 ′ | , for all /u1D450 , /u1D450 ′ in Col /u1D45B such that /u1D450 |Y /u1D450 ′ ≠ /u1D450 ★ /u1D446 /u1D45F /u1D450 ′ . Prove that starting from a string of columns consisting of three columns | /u1D450 /u1D456 | /u1D450 /u1D457 | /u1D450 /u1D458 | , we lead to the Young tableau | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 ★ /u1D446 /u1D45F /u1D450 /u1D458 | after applying at most three steps of reductions with respect R( Col /u1D45B , Y /u1D45F /u1D45B ) starting from the left or from the right. We prove this result using Schützenberger's involution on columns as in [10, Remark 3.2.7]. In one hand, by definition of Schensted's insertion /u1D446 /u1D45F , starting from | /u1D450 /u1D456 | /u1D450 /u1D457 | /u1D450 /u1D458 | , we lead to | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 ★ /u1D446 /u1D45F /u1D450 /u1D458 | after applying at most three steps of reductions with respect R( Col /u1D45B , Y /u1D45F /u1D45B ) starting from the left. That is, we have

<!-- formula-not-decoded -->

In an other hand, we have

<!-- formula-not-decoded -->

Let us show that | /u1D450 /u1D45A | ( /u1D450 /u1D45A ′ ★ /u1D460 /u1D45F /u1D450 /u1D459 ′ )| = | /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 ★ /u1D446 /u1D45F /u1D450 /u1D458 | . By applying the involution on tableaux, we obtain

<!-- formula-not-decoded -->

By definition of /u1D446 /u1D45F , we have | /u1D450 ∗ /u1D458 ★ /u1D446 /u1D45F /u1D450 ∗ /u1D457 ★ /u1D460 /u1D45F /u1D450 ∗ /u1D456 | = | ( /u1D450 ∗ /u1D459 ′ ★ /u1D446 /u1D45F /u1D450 ∗ /u1D45A ′ )| /u1D450 ∗ /u1D45A | . Since ( /u1D450 ∗ /u1D458 ★ /u1D460 /u1D45F /u1D450 ∗ /u1D457 ★ /u1D446 /u1D45F /u1D450 ∗ /u1D456 ) = ( /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 ★ /u1D446 /u1D45F /u1D450 /u1D458 ) ∗ , we deduce that | ( /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 ★ /u1D446 /u1D45F /u1D450 /u1D458 ) ∗ | = | ( /u1D450 ∗ /u1D459 ′ ★ /u1D446 /u1D45F /u1D450 ∗ /u1D45A ′ )| /u1D450 ∗ /u1D45A | . Finally, by applying the involution on tableaux, we obtain | ( /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D457 ★ /u1D446 /u1D45F /u1D450 /u1D458 )| = | /u1D450 /u1D45A | ( /u1D450 /u1D45A ′ ★ /u1D446 /u1D45F /u1D450 /u1D459 ′ )| .

Following Lemma 3.2.4, for any rule | /u1D450 /u1D456 1 | /u1D450 /u1D456 2 | ⇒| /u1D450 /u1D457 1 | /u1D450 /u1D457 2 | in FS /u1D45B , we have | /u1D450 /u1D456 1 ★ /u1D446 /u1D45F /u1D450 /u1D456 2 | = /u1D70C /latticetop FS /u1D45B (| /u1D450 /u1D457 1 | /u1D450 /u1D457 2 |) . Hence, any critical branching of TS /u1D45B has the following confluence diagram

/d40

/d60

/d37

/d57

/d37

/d57

/d37

/d57

<!-- image -->

/d34

/d54

/d37

/d57

/d37

/d57

/d37

/d57

where /u1D700 1 and /u1D700 2 are TS /u1D45B -reductions and where some indicated rules can correspond to identities, such that /u1D450 /u1D458 |Y /u1D450 /u1D458 ′ = /u1D450 /u1D457 ★ /u1D446 /u1D45F /u1D450 /u1D457 ′ , /u1D450 /u1D459 |Y /u1D450 /u1D459 ′ = /u1D450 /u1D458 ′ ★ /u1D446 /u1D45F /u1D450 /u1D456 ′′ , /u1D450 /u1D458 ′ |Y /u1D450 /u1D459 ′′ = /u1D450 /u1D458 ★ /u1D446 /u1D45F /u1D450 /u1D459 , /u1D450 /u1D45B |Y /u1D450 /u1D45B ′ = /u1D450 /u1D45A ★ /u1D446 /u1D45F /u1D450 /u1D45A ′ , /u1D450 /u1D458 ′ |Y /u1D450 /u1D460 ′ = /u1D450 /u1D456 ★ /u1D446 /u1D45F /u1D450 /u1D45B and /u1D450 /u1D459 ′′ |Y /u1D450 /u1D459 ′ = /u1D450 /u1D460 ′ ★ /u1D446 /u1D45F /u1D450 /u1D45B ′ . /square

/d42

/d62

/d32

/d52

## 3.3. Jeu de taquin as morphism of monoids

In this subsection, we prove the compatibility of the rewriting system FS /u1D45B with the plactic congruence.

3.3.1. Theorem. The rectification map /u1D70B /u1D461 /u1D45E : dSk /u1D45B → Yt /u1D45B is a surjective map that satisfies the following two properties:

- i) for any rule /u1D451 ⇒ /u1D451 ′ in FS /u1D45B , we have /u1D445 /u1D446/u1D44A ( /u1D451 ) ≈ P /u1D45B /u1D445 /u1D446/u1D44A ( /u1D451 ′ ) ,
2. ii) for all /u1D464 , /u1D464 ′ ∈ [ /u1D45B ] ∗ , /u1D464 ≈ P /u1D45B /u1D464 ′ implies Nf ([ /u1D464 ] /u1D460 , FS /u1D45B ) = Nf ([ /u1D464 ′ ] /u1D460 , FS /u1D45B ) .

Proof. The surjectivity of /u1D70B /u1D461 /u1D45E is a consequence of the relation /u1D70B /u1D461 /u1D45E ([ /u1D445 /u1D446/u1D44A ( /u1D451 )] /u1D460 ) = /u1D451 , that holds for any /u1D451 in Yt /u1D45B . Prove first that for any rule /u1D451 ⇒ /u1D451 ′ in FS /u1D45B , we have /u1D445 /u1D446/u1D44A ( /u1D451 ) ≈ P /u1D45B /u1D445 /u1D446/u1D44A ( /u1D451 ′ ) . It suffices to show that /u1D445 /u1D446/u1D44A ( /u1D460 ( /u1D702 )) ≈ P /u1D45B /u1D445 /u1D446/u1D44A ( /u1D461 ( /u1D702 )) , for every rule /u1D702 in FS /u1D45B . This is obvious for /u1D6FE and /u1D6FF . For the rule /u1D6FC , consider /u1D445 /u1D446/u1D44A ( /u1D460 ( /u1D6FC )) = /u1D450 /u1D456 1 /u1D456 . . . /u1D450 1 /u1D456 /u1D450 /u1D456 2 /u1D457 . . . /u1D450 /u1D45A + 1 /u1D457 /u1D450 /u1D45A /u1D457 . . . /u1D450 1 /u1D457 and /u1D445 /u1D446/u1D44A ( /u1D461 ( /u1D6FC )) = /u1D450 /u1D456 2 /u1D457 . . . /u1D450 /u1D45A + 1 /u1D457 /u1D450 /u1D456 1 /u1D456 . . . /u1D450 1 /u1D456 /u1D450 /u1D45A /u1D457 . . . /u1D450 1 /u1D457 . On one hand, we have

<!-- formula-not-decoded -->

In an other hand, we have /u1D450 /u1D456 2 /u1D457 . . . /u1D450 /u1D45A + 1 /u1D457 /u1D450 /u1D456 1 /u1D456 . . . c 2 i c 1 i c m j . . . /u1D450 1 /u1D457 ( 3 . 1 . 2 ) = . . . ( 3 . 1 . 2 ) = /u1D450 /u1D456 2 /u1D457 . . . /u1D450 /u1D45A + 1 /u1D457 /u1D450 /u1D45A /u1D457 /u1D450 /u1D456 1 /u1D456 . . . /u1D450 1 /u1D456 /u1D450 /u1D45A -1 /u1D457 . . . /u1D450 1 /u1D457 . Hence, /u1D445 /u1D446/u1D44A ( /u1D460 ( /u1D6FC )) ≈ P /u1D45B /u1D445 /u1D446/u1D44A ( /u1D461 ( /u1D6FC )) . Similarly, we show the property for rules /u1D6FD , /u1D6FF /u1D6FC and /u1D6FF /u1D6FD .

Prove now that for all /u1D464 , /u1D464 ′ ∈ [ /u1D45B ] ∗ , /u1D464 ≈ P /u1D45B /u1D464 ′ implies Nf ([ /u1D464 ] /u1D460 , FS /u1D45B ) = Nf ([ /u1D464 ′ ] /u1D460 , FS /u1D45B ) . Since FS /u1D45B is convergent, we show that for all /u1D464 , /u1D464 ′ ∈ [ /u1D45B ] ∗ , /u1D464 ≈ P /u1D45B /u1D464 ′ implies [ /u1D464 ] /u1D460 ≈FS /u1D45B [ /u1D464 ′ ] /u1D460 . Suppose first that /u1D464 = /u1D462/u1D465 1 xzy /u1D466.alt 1 /u1D463 and /u1D464 ′ = /u1D462/u1D465 1 zxy /u1D466.alt 1 /u1D463 , for all 1 /lessorequalslant /u1D465 /lessorequalslant /u1D466.alt &lt; /u1D467 /lessorequalslant /u1D45B , /u1D462, /u1D463 ∈ [ /u1D45B ] ∗ and /u1D465 1 , /u1D466.alt 1 ∈ [ /u1D45B ] , and show that [ /u1D464 ] /u1D460 ≈FS /u1D45B [ /u1D464 ′ ] /u1D460 . We consider the following cases:

Case 1. /u1D465 1 /lessorequalslant /u1D465 and /u1D466.alt /lessorequalslant /u1D466.alt 1 .

/d15

/d15

/d96

/d116

/d37

/d57

/d15

/d15

/d5

/d25

<!-- formula-not-decoded -->

Case 2. /u1D465 1 /lessorequalslant /u1D465 and /u1D466.alt &gt; /u1D466.alt 1. Suppose that /u1D463 = /u1D466.alt 2 . . . /u1D466.alt /u1D45E /u1D466.alt ′ /u1D463 ′ such that /u1D466.alt 1 &gt; /u1D466.alt 2 &gt; . . . &gt; /u1D466.alt /u1D45E and /u1D466.alt /u1D45E /lessorequalslant /u1D466.alt ′ .

/d37

/d57

<!-- image -->

/d101

/d121

Case 3. /u1D465 &lt; /u1D467 &lt; /u1D465 1 and /u1D466.alt /lessorequalslant /u1D466.alt 1. Suppose that /u1D462 = /u1D462 ′ /u1D465 ′ /u1D465 /u1D45D . . . /u1D465 1 such that /u1D465 ′ /lessorequalslant /u1D465 /u1D45D and /u1D465 /u1D45D &gt; . . . &gt; /u1D465 1 .

/d37

/d57

<!-- image -->

/d101

/d121

The case /u1D465 &lt; /u1D467 &lt; /u1D465 1 and /u1D466.alt &gt; /u1D466.alt 1 is studied in the same way.

Case 4. /u1D465 &lt; /u1D465 1 /lessorequalslant /u1D467 and /u1D466.alt &gt; /u1D466.alt 1 . We study similarly the case /u1D465 &lt; /u1D465 1 /lessorequalslant /u1D467 and /u1D466.alt /lessorequalslant /u1D466.alt 1 . Suppose that /u1D462 = /u1D462 ′ /u1D465 ′ /u1D465 /u1D45D . . . /u1D465 1 and /u1D463 = /u1D466.alt 2 . . . /u1D466.alt /u1D45E /u1D466.alt ′ /u1D463 ′ such that /u1D465 ′ /lessorequalslant /u1D465 /u1D45D &gt; . . . &gt; /u1D465 1 and /u1D466.alt 1 &gt; . . . &gt; /u1D466.alt /u1D45E /lessorequalslant /u1D466.alt ′ .

/d37

/d57

<!-- image -->

/d15

/d15

/d5

/d25

/d15

/d15

/d15

/d15

/d5

/d25

/d37

/d57

/d15

/d15

/d15

/d15

/d5

/d25

/d15

/d15

/d69

/d89

## 3. Convergence of the jeu de taquin

Suppose now that /u1D464 = /u1D462/u1D466.alt 1 yzx /u1D465 1 /u1D463 and /u1D464 ′ = /u1D462/u1D466.alt 1 yxz /u1D465 1 /u1D463 , for all 1 /lessorequalslant /u1D465 &lt; /u1D466.alt /lessorequalslant /u1D467 /lessorequalslant /u1D45B , /u1D462, /u1D463 ∈ [ /u1D45B ] ∗ and /u1D465 1 , /u1D466.alt 1 ∈ [ /u1D45B ] , and show that [ /u1D464 ] /u1D460 ≈FS /u1D45B [ /u1D464 ′ ] /u1D460 . If /u1D466.alt 1 /lessorequalslant /u1D466.alt and /u1D465 /lessorequalslant /u1D465 1, then

/d37

/d57

<!-- formula-not-decoded -->

/d37

/d57

The cases ( /u1D466.alt 1 &gt; /u1D466.alt and /u1D465 &gt; /u1D465 1 ), ( /u1D466.alt 1 /lessorequalslant /u1D466.alt and /u1D465 &gt; /u1D465 1 ) and ( /u1D466.alt 1 &gt; /u1D466.alt and /u1D465 /lessorequalslant /u1D465 1 ) are studied similarly. /square

As a consequence of Theorem 3.2.3 and Theorem 3.3.1, we recover that the set of Young tableaux satisfies the cross-section property for the plactic monoid, we also deduce the commutation of Schensted's left and right insertion algorithm and that the rectification map defines a surjective morphism of monoids between the sets /u1D451 S /u1D45F /u1D45B and Y /u1D45F /u1D45B equipped with the insertion products ★ /u1D43C /u1D44E /u1D45F and ★ /u1D446 /u1D45F .

## 3.3.2. Corollary (cross-section property). The following conditions hold

- i) for all /u1D464 , /u1D464 ′ in [ /u1D45B ] ∗ , we have /u1D464 ≈ P /u1D45B /u1D464 ′ if and only if /u1D436 Y /u1D45F /u1D45B ( /u1D464 ) = /u1D436 Y /u1D45F /u1D45B ( /u1D464 ′ ) ,
2. ii) the equality /u1D436 Y /u1D45F /u1D45B ( /u1D445 /u1D446/u1D44A ( /u1D451 )) = /u1D436 Y /u1D45F /u1D45B ( /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 ))) holds in Yt /u1D45B , for any /u1D451 in dSk /u1D45B .

Proof. Prove Condition i) . Consider two words /u1D464 and /u1D464 ′ over [ /u1D45B ] . If /u1D464 ≈ P /u1D45B /u1D464 ′ , then by Theorem 3.3.1 we have Nf ([ /u1D464 ] /u1D460 , FS /u1D45B ) = Nf ([ /u1D464 ′ ] /u1D460 , FS /u1D45B ) and thus /u1D436 Y /u1D45F /u1D45B ( /u1D464 ) = /u1D436 Y /u1D45F /u1D45B ( /u1D464 ′ ) by Theorem 3.2.3. Suppose now that /u1D436 Y /u1D45F /u1D45B ( /u1D464 ) = /u1D436 Y /u1D45F /u1D45B ( /u1D464 ′ ) . Following Theorem 3.2.3, we have Nf ([ /u1D464 ] /u1D460 , FS /u1D45B ) = Nf ([ /u1D464 ′ ] /u1D460 , FS /u1D45B ) , and then /u1D464 ≈ P /u1D45B /u1D464 ′ by Theorem 3.3.1.

Prove Condition ii) . Following Theorem 3.2.3, for any /u1D451 in dSk /u1D45B , we have /u1D70B /u1D461 /u1D45E ( /u1D451 ) = /u1D436 Y /u1D45F /u1D45B ( /u1D445 /u1D446/u1D44A ( /u1D451 )) , showing the claim. /square

- 3.3.3. Corollary (commutation of insertion algorithms). i) For all /u1D451 in dSk /u1D45B and /u1D465 in [ /u1D45B ] , we have /u1D70B /u1D461 /u1D45E ( /u1D451 /squiggleright /u1D43C /u1D44E /u1D45F /u1D465 ) = /u1D70B /u1D461 /u1D45E ( /u1D451 ) /squiggleright /u1D446 /u1D45F /u1D465 and /u1D70B /u1D461 /u1D45E ( /u1D465 /squiggleright /u1D43C /u1D44E /u1D459 /u1D451 ) = /u1D465 /squiggleright /u1D446 /u1D459 /u1D70B /u1D461 /u1D45E ( /u1D451 ) .
- ii) The insertion algorithms /u1D446 /u1D45F and /u1D446 /u1D459 commute, that is the following equality

<!-- formula-not-decoded -->

holds in Yt /u1D45B , for all /u1D461 in Yt /u1D45B and /u1D465 in [ /u1D45B ] .

Proof. Prove Condition i) . By Theorem 3.3.1, we have /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 /squiggleright /u1D43C /u1D44E /u1D45F /u1D465 )) ≈ P /u1D45B /u1D445 /u1D446/u1D44A ( /u1D451 /squiggleright /u1D43C /u1D44E /u1D45F /u1D465 ) . Moreover, we have /u1D445 /u1D446/u1D44A ( /u1D451 /squiggleright /u1D43C /u1D44E /u1D45F /u1D465 ) = /u1D445 /u1D446/u1D44A ( /u1D451 ) /u1D465 , hence /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 /squiggleright /u1D43C /u1D44E /u1D45F /u1D465 )) ≈ P /u1D45B /u1D445 /u1D446/u1D44A ( /u1D451 ) /u1D465 . On the other hand, the following equalities holds in Yt /u1D45B :

<!-- formula-not-decoded -->

Then /u1D70B /u1D461 /u1D45E ( /u1D451 ) /squiggleright /u1D446 /u1D45F /u1D465 ≈FS /u1D45B [ /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 )) /u1D465 ] /u1D460 , and thus by Theorem 3.3.1, we deduce

<!-- formula-not-decoded -->

showing that /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 /squiggleright /u1D43C /u1D44E /u1D45F /u1D465 )) ≈ P /u1D45B /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 ) /squiggleright /u1D446 /u1D45F /u1D465 ) . Finally, following the cross-section property, we obtain /u1D70B /u1D461 /u1D45E ( /u1D451 /squiggleright /u1D43C /u1D44E /u1D45F /u1D465 ) = /u1D70B /u1D461 /u1D45E ( /u1D451 ) /squiggleright /u1D43C /u1D44E /u1D45F /u1D465 . Similarly, we show that /u1D70B /u1D461 /u1D45E ( /u1D465 /squiggleright /u1D43C /u1D44E /u1D459 /u1D451 ) = /u1D465 /squiggleright /u1D446 /u1D459 /u1D70B /u1D461 /u1D45E ( /u1D451 ) .

/d15

/d15

/d15

/d15

and

<!-- formula-not-decoded -->

for all /u1D451 in /u1D437 and /u1D465 , /u1D466.alt in [ /u1D45B ] . By commutation of /u1D43C /u1D44E /u1D45F and /u1D43C /u1D44E /u1D45F , we deduce the following equality

<!-- formula-not-decoded -->

The map /u1D70B /u1D461 /u1D45E being surjective, we deduce that /u1D446 /u1D45F and /u1D446 /u1D459 commute.

/square

3.3.4. Corollary (morphismof monoids). The map /u1D70B /u1D461 /u1D45E induces a morphism of monoids between ( /u1D451 S /u1D45F /u1D45B , ★ /u1D43C /u1D44E /u1D45F ) and ( Y /u1D45F /u1D45B , ★ /u1D446 /u1D45F ) .

Proof. Following Condition i) of Corollary 3.3.3, we first prove that /u1D70B /u1D461 /u1D45E ( /u1D451 /squiggleright /u1D43C /u1D44E /u1D45F /u1D462 ) = /u1D70B /u1D461 /u1D45E ( /u1D451 ) /squiggleright /u1D446 /u1D45F /u1D462 , for all /u1D451 in dSk /u1D45B and /u1D462 in [ /u1D45B ] ∗ by induction on | /u1D462 | . Suppose the equality holds when | /u1D462 | = /u1D458 -1, then for /u1D466.alt in [ /u1D45B ] we have

<!-- formula-not-decoded -->

In an other hand, following Condition ii) of Corollary 3.3.2, we have /u1D436 Y /u1D45F /u1D45B ( /u1D445 /u1D446/u1D44A ( /u1D451 ′ )) = /u1D436 Y /u1D45F /u1D45B ( /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 ′ ))) , for all /u1D451 ′ in dSk /u1D45B , hence /u1D436 Y /u1D45F /u1D45B ( /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 )) /u1D445 /u1D446/u1D44A ( /u1D451 ′ )) = /u1D436 Y /u1D45F /u1D45B ( /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 )) /u1D445 /u1D446/u1D44A ( /u1D70B /u1D461 /u1D45E ( /u1D451 ′ ))) . As a consequence, we have

<!-- formula-not-decoded -->

for all /u1D451 , /u1D451 ′ in dSk /u1D45B , showing the claim.

Prove Condition ii) . Following Condition i) , we have

<!-- formula-not-decoded -->

/square

3.3.5. Remark. Note that Schensted's insertion algorithms are related to the jeu de taquin by the following formulas

<!-- formula-not-decoded -->

for all /u1D461 in Yt /u1D45B and /u1D465 in [ /u1D45B ] . Note also that the associativity of ★ /u1D446 /u1D45F is also deduced from the morphism /u1D70B /u1D461 /u1D45E . Indeed, for all /u1D461 in Yt /u1D45B , and /u1D465 in [ /u1D45B ] , we have /u1D461 /squiggleright /u1D446 /u1D45F /u1D465 = /u1D70B /u1D461 /u1D45E ( /u1D461 | 1 /u1D465 ) , and thus /u1D461 ★ /u1D446 /u1D45F /u1D461 ′ = /u1D70B /u1D461 /u1D45E ( /u1D461 | /u1D460 /u1D461 ′ ) , for all /u1D461 , /u1D461 ′ ∈ Yt /u1D45B . By Theorem 3.2.3, we obtain

<!-- formula-not-decoded -->

for any /u1D461 , /u1D461 ′ , /u1D461 ′′ ∈ Yt /u1D45B .

## 4. Conclusion and perspectives

In this article, we have introduced the notion of string of columns rewriting system as rewriting systems over glued sequences of columns. This gives a rewriting framework to prove the confluence of Schützenberger's jeu de taquin algorithm defined on the structure of tableaux. Our construction leads us to formulate several perspectives:

- In [10], we make explicit the relations among the relations of the Knuth relations for the plactic monoid of type A. We expect that the rewriting presentation of the jeu de taquin introduced in this article could make explicit the relations among the relations for the cross-section property on sequence of columns for the plactic monoid of type A. Such a study of the relations among the relations for the presentations of a monoid constitutes the first step in an explicit construction of a cofibrant approximation of the monoid in the category of ( /u1D714 , 1 ) -categories and of actions of the monoid on categories, see [5, 6, 10, 11].
- Schützenberger's jeu de taquin gives a proof of the Littlewood-Richardson rule which is a combinatorial description of the coefficients that arise when decomposing a product of two Schur polynomials as a linear combination of other Schur polynomials. In particular, these coefficients count certain types of skew tableaux that are rectified by the jeu de taquin to Young tableaux. We except that these coefficients could be also described by a rewriting approach using a zigzag sequences of reductions from certain types of skew tableaux to their normal forms with respect to the rewriting presentation of the jeu de taquin introduced in this article.
- The construction applied in this article on the jeu de taquin could be also applied on similar algorithms defined on other structures of tableaux, [9, 15, 16, 20, 23, 24]. In particular, we expect constructive proofs by rewriting of the properties relating these algorithms to the plactic monoids of classical types and the super plactic monoid which are respectively related to the representations of the finite dimensional semisimple Lie algebras of classical types and the general Lie superalgebra.

## References

- [1] David Aldous and Persi Diaconis. Longest increasing subsequences: from patience sorting to the Baik-DeiftJohansson theorem. Bull. Amer. Math. Soc. (N.S.) , 36(4):413-432, 1999.
- [2] Alan J. Cain, Robert D. Gray, and António Malheiro. Crystal monoids &amp; crystal bases: rewriting systems and biautomatic structures for plactic monoids of types /u1D434 /u1D45B , /u1D435 /u1D45B , /u1D436 /u1D45B , /u1D437 /u1D45B , and /u1D43A 2 . J. Combin. Theory Ser. A , 162:406-466, 2019.
- [3] Neil O Connell. Conditioned random walks and the RSK correspondence. Journal of Physics A: Mathematical and General , 36(12):3049-3066, mar 2003.
- [4] William Fulton. Young tableaux , volume 35 of London Mathematical Society Student Texts . Cambridge University Press, Cambridge, 1997. With applications to representation theory and geometry.
- [5] Stéphane Gaussent, Yves Guiraud, and Philippe Malbos. Coherent presentations of Artin monoids. Compos. Math. , 151(5):957-998, 2015.

- [6] Yves Guiraud and Philippe Malbos. Higher-dimensional normalisation strategies for acyclicity. Adv. Math. , 231(3-4):2294-2351, 2012.
- [7] Yves Guiraud and Philippe Malbos. Polygraphs of finite derivation type. Math. Structures Comput. Sci. , 28(2):155-201, 2018.
- [8] Nohra Hage. Finite convergent presentation of plactic monoid for type C. Internat. J. Algebra Comput. , 25(8):1239-1263, 2015.
- [9] Nohra Hage. Super jeu de taquin and combinatorics of super tableaux of type A. arxiv:2105.07819, May 2021.
- [10] Nohra Hage and Philippe Malbos. Knuth's coherent presentations of plactic monoids of type A. Algebr. Represent. Theory , 20(5):1259-1288, 2017.
- [11] Nohra Hage and Philippe Malbos. Super Chinese syzygies by insertions. Semigroup Forum , 104(1):88-108, 2022.
- [12] Masaki Kashiwara and Toshiki Nakashima. Crystal graphs for representations of the /u1D45E -analogue of classical Lie algebras. J. Algebra , 165(2):295-345, 1994.
- [13] Donald E. Knuth. Permutations, matrices, and generalized Young tableaux. Pacific J. Math. , 34:709-727, 1970.
- [14] Alain Lascoux and Marcel-P. Schützenberger. Le monoïde plaxique. In Noncommutative structures in algebra and geometric combinatorics (Naples, 1978) , volume 109 of Quad. 'Ricerca Sci.' , pages 129-156. CNR, Rome, 1981.
- [15] Cédric Lecouvey. Schensted-type correspondence, plactic monoid, and jeu de taquin for type /u1D436 /u1D45B . J. Algebra , 247(2):295-331, 2002.
- [16] Cedric Lecouvey. Schensted-type correspondences and plactic monoids for types /u1D435 /u1D45B and /u1D437 /u1D45B . J. Algebraic Combin. , 18(2):99-133, 2003.
- [17] M. Lothaire. Algebraic combinatorics on words , volume 90 of Encyclopedia of Mathematics and its Applications . Cambridge University Press, Cambridge, 2002.
- [18] Maxwell Newman. On theories with a combinatorial definition of 'equivalence'. Ann. of Math. (2) , 43(2):223243, 1942.
- [19] Jean-Christophe Novelli. On the hypoplactic monoid. volume 217, pages 315-336. 2000. Formal power series and algebraic combinatorics (Vienna, 1997).
- [20] Dan Romik and Piotr Śniady. Jeu de taquin dynamics on infinite Young tableaux and second class particles. The Annals of Probability , 43(2):682-737, 2015.
- [21] C. Schensted. Longest increasing and decreasing subsequences. Canad. J. Math. , 13:179-191, 1961.
- [22] M.-P. Schützenberger. La correspondance de Robinson. pages 59-113. Lecture Notes in Math., Vol. 579, 1977.
- [23] Vasu Tewari. Backward jeu de taquin slides for composition tableaux and a noncommutative pieri rule. Electron. J. Comb. , 22:P1.42, 2015.

## REFERENCES

- [24] Hugh Thomas and Alexander Yong. A jeu de taquin theory for increasing tableaux, with applications to k-theoretic schubert calculus. Algebra and Number Theory , 3(2):121-148, 2009.
- [25] Marc A. A. van Leeuwen. The Littlewood-Richardson rule, and related combinatorics. In Interaction of combinatorics and representation theory , volume 11 of MSJ Mem. , pages 95-145. Math. Soc. Japan, Tokyo, 2001.
- [26] Alfred Young. On Quantitative Substitutional Analysis. Proc. London Math. Soc. (2) , 28(4):255-292, 1928.

Nohra Hage nohra.hage@univ-catholille.fr Faculté de Gestion, Economie &amp; Sciences (FGES), Université Catholique de Lille, 60 bd Vauban, CS 40109, 59016 Lille Cedex, France

Philippe Malbos malbos@math.univ-lyon1.fr Univ Lyon, Université Claude Bernard Lyon 1 CNRS UMR 5208, Institut Camille Jordan 43 blvd. du 11 novembre 1918 F-69622 Villeurbanne cedex, France

- November 27, 2024 -15:41 -