use crate::{ConversionResult, DoclingError, Document, DocumentMetadata, InputFormat, Result};
use pyo3::prelude::*;
use pyo3::types::PyModule;
use std::path::{Path, PathBuf};
use std::time::Instant;

/// Main document converter for processing documents into structured text.
///
/// `DocumentConverter` is the primary interface for converting documents from various
/// formats (PDF, DOCX, HTML, etc.) into markdown or structured content. It supports
/// OCR for scanned documents and table extraction.
///
/// # Examples
///
/// ## Basic Conversion
///
/// ```rust,no_run
/// use docling_core::{DocumentConverter, Result};
///
/// fn main() -> Result<()> {
///     // Create converter with default settings (text-only mode)
///     let converter = DocumentConverter::new()?;
///
///     // Convert a PDF document
///     let result = converter.convert("document.pdf")?;
///
///     println!("Markdown:\n{}", result.document.markdown);
///     println!("Conversion time: {:?}", result.latency);
///
///     Ok(())
/// }
/// ```
///
/// ## OCR for Scanned Documents
///
/// ```rust,no_run
/// use docling_core::{DocumentConverter, Result};
///
/// fn main() -> Result<()> {
///     // Enable OCR for scanned PDFs and images
///     let converter = DocumentConverter::with_ocr(true)?;
///
///     let result = converter.convert("scanned_invoice.pdf")?;
///     println!("Extracted text: {}", result.document.markdown);
///
///     Ok(())
/// }
/// ```
///
/// ## Batch Processing
///
/// ```rust,no_run
/// use docling_core::{DocumentConverter, Result};
///
/// fn main() -> Result<()> {
///     let converter = DocumentConverter::new()?;
///     let documents = vec!["paper1.pdf", "report2.docx", "article3.html"];
///
///     for doc in documents {
///         match converter.convert(doc) {
///             Ok(result) => println!("✓ {}: {} chars", doc, result.document.metadata.num_characters),
///             Err(e) => eprintln!("✗ {}: {}", doc, e),
///         }
///     }
///
///     Ok(())
/// }
/// ```
///
/// ## Error Handling
///
/// ```rust,no_run
/// use docling_core::{DocumentConverter, DoclingError, Result};
///
/// fn convert_document(path: &str) -> Result<String> {
///     let converter = DocumentConverter::new()?;
///
///     match converter.convert(path) {
///         Ok(result) => Ok(result.document.markdown),
///         Err(DoclingError::FileNotFound(msg)) => {
///             eprintln!("File missing: {}", msg);
///             Err(DoclingError::FileNotFound(msg))
///         }
///         Err(e) => {
///             eprintln!("Conversion failed: {}", e);
///             Err(e)
///         }
///     }
/// }
/// ```
pub struct DocumentConverter {
    py_converter: Py<PyAny>,
}

impl DocumentConverter {
    /// Creates a new converter with default text-only configuration.
    ///
    /// This creates a converter with OCR disabled, which is faster but only works
    /// with documents that have embedded text (not scanned images).
    ///
    /// For scanned documents or images, use [`with_ocr`](Self::with_ocr) instead.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use docling_core::DocumentConverter;
    ///
    /// let converter = DocumentConverter::new()?;
    /// # Ok::<(), docling_core::DoclingError>(())
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if the Python docling package cannot be initialized.
    pub fn new() -> Result<Self> {
        Self::with_ocr(false)
    }

    /// Creates a converter with specific OCR configuration.
    ///
    /// When OCR is enabled, the converter can extract text from scanned documents
    /// and images. This is slower but more versatile than text-only mode.
    ///
    /// # Parameters
    ///
    /// - `enable_ocr`: If `true`, enables OCR for scanned documents and images.
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use docling_core::DocumentConverter;
    ///
    /// // Enable OCR for scanned documents
    /// let converter = DocumentConverter::with_ocr(true)?;
    /// let result = converter.convert("scanned_form.pdf")?;
    /// # Ok::<(), docling_core::DoclingError>(())
    /// ```
    ///
    /// ```rust,no_run
    /// use docling_core::DocumentConverter;
    ///
    /// // Disable OCR for faster processing of text PDFs
    /// let converter = DocumentConverter::with_ocr(false)?;
    /// let result = converter.convert("digital_report.pdf")?;
    /// # Ok::<(), docling_core::DoclingError>(())
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if the Python docling package cannot be initialized
    /// or if OCR dependencies are missing.
    pub fn with_ocr(enable_ocr: bool) -> Result<Self> {
        Python::attach(|py| {
            // Configure PDF pipeline to match upstream test configuration
            let pipeline_options_module =
                PyModule::import(py, "docling.datamodel.pipeline_options").map_err(|e| {
                    DoclingError::PythonError(format!("Failed to import pipeline_options: {e}"))
                })?;

            let pdf_options_class = pipeline_options_module
                .getattr("PdfPipelineOptions")
                .map_err(|e| {
                    DoclingError::PythonError(format!("Failed to get PdfPipelineOptions: {e}"))
                })?;

            let pdf_options = pdf_options_class.call0().map_err(|e| {
                DoclingError::PythonError(format!("Failed to create PdfPipelineOptions: {e}"))
            })?;

            // Set OCR mode (configurable)
            pdf_options.setattr("do_ocr", enable_ocr)?;
            // Set: do_table_structure = True (match upstream)
            pdf_options.setattr("do_table_structure", true)?;

            // Configure format options
            let format_option_module =
                PyModule::import(py, "docling.document_converter").map_err(|e| {
                    DoclingError::PythonError(format!("Failed to import document_converter: {e}"))
                })?;

            let pdf_format_option_class =
                format_option_module
                    .getattr("PdfFormatOption")
                    .map_err(|e| {
                        DoclingError::PythonError(format!("Failed to get PdfFormatOption: {e}"))
                    })?;

            let pdf_format_option = pdf_format_option_class.call0().map_err(|e| {
                DoclingError::PythonError(format!("Failed to create PdfFormatOption: {e}"))
            })?;

            pdf_format_option.setattr("pipeline_options", pdf_options)?;

            // Create format_options dict
            let input_format = PyModule::import(py, "docling.datamodel.base_models")
                .map_err(|e| {
                    DoclingError::PythonError(format!("Failed to import base_models: {e}"))
                })?
                .getattr("InputFormat")?;

            let pdf_format = input_format.getattr("PDF")?;

            let format_options = pyo3::types::PyDict::new(py);
            format_options.set_item(pdf_format, pdf_format_option)?;

            // Get DocumentConverter class
            let converter_class =
                format_option_module
                    .getattr("DocumentConverter")
                    .map_err(|e| {
                        DoclingError::PythonError(format!(
                            "Failed to get DocumentConverter class: {e}"
                        ))
                    })?;

            // Instantiate with format_options
            let kwargs = pyo3::types::PyDict::new(py);
            kwargs.set_item("format_options", format_options)?;

            let py_converter = converter_class.call((), Some(&kwargs)).map_err(|e| {
                DoclingError::PythonError(format!("Failed to create DocumentConverter: {e}"))
            })?;

            Ok(Self {
                py_converter: py_converter.into(),
            })
        })
    }

    /// Converts a document to markdown format.
    ///
    /// This method processes a document file and returns structured markdown output
    /// along with metadata and performance metrics. It automatically detects the
    /// input format based on the file extension.
    ///
    /// # Supported Formats
    ///
    /// - **Documents**: PDF, DOCX, DOC, PPTX, XLSX, RTF
    /// - **Web**: HTML, Markdown, `AsciiDoc`, CSV
    /// - **Images**: PNG, JPEG, TIFF, WebP, BMP (requires OCR)
    /// - **E-books**: EPUB, MOBI, AZW, FB2
    /// - **Archives**: ZIP, TAR, GZ, 7Z, RAR
    /// - **Specialty**: JATS XML, `OpenDocument`, XPS, EML, MSG
    ///
    /// # Parameters
    ///
    /// - `path`: Path to the document file (any type that implements `AsRef<Path>`)
    ///
    /// # Returns
    ///
    /// Returns a [`ConversionResult`] containing:
    /// - `document`: The converted document with markdown and metadata
    /// - `latency`: Time taken for the conversion
    ///
    /// # Examples
    ///
    /// ## Basic Conversion
    ///
    /// ```rust,no_run
    /// use docling_core::DocumentConverter;
    ///
    /// let converter = DocumentConverter::new()?;
    /// let result = converter.convert("document.pdf")?;
    ///
    /// println!("Markdown:\n{}", result.document.markdown);
    /// println!("Characters: {}", result.document.metadata.num_characters);
    /// println!("Conversion time: {:?}", result.latency);
    /// # Ok::<(), docling_core::DoclingError>(())
    /// ```
    ///
    /// ## Multiple Formats
    ///
    /// ```rust,no_run
    /// use docling_core::DocumentConverter;
    ///
    /// let converter = DocumentConverter::new()?;
    ///
    /// // PDF document
    /// let pdf_result = converter.convert("report.pdf")?;
    ///
    /// // Word document
    /// let docx_result = converter.convert("letter.docx")?;
    ///
    /// // HTML page
    /// let html_result = converter.convert("article.html")?;
    /// # Ok::<(), docling_core::DoclingError>(())
    /// ```
    ///
    /// ## With OCR for Images
    ///
    /// ```rust,no_run
    /// use docling_core::DocumentConverter;
    ///
    /// let converter = DocumentConverter::with_ocr(true)?;
    ///
    /// // Convert image with OCR
    /// let result = converter.convert("screenshot.png")?;
    /// println!("Extracted text: {}", result.document.markdown);
    /// # Ok::<(), docling_core::DoclingError>(())
    /// ```
    ///
    /// ## Using `PathBuf`
    ///
    /// ```rust,no_run
    /// use docling_core::DocumentConverter;
    /// use std::path::PathBuf;
    ///
    /// let converter = DocumentConverter::new()?;
    /// let path = PathBuf::from("documents/report.pdf");
    /// let result = converter.convert(&path)?;
    /// # Ok::<(), docling_core::DoclingError>(())
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - File does not exist ([`DoclingError::IoError`])
    /// - Format is unsupported ([`DoclingError::FormatError`])
    /// - Conversion fails ([`DoclingError::ConversionError`])
    /// - Python backend fails ([`DoclingError::PythonError`])
    ///
    /// # Performance
    ///
    /// Conversion time varies by format and document complexity:
    /// - Simple text PDFs: 100-500ms
    /// - Complex PDFs with tables: 500-2000ms
    /// - OCR processing: 2-10 seconds per page
    /// - Office documents: 200-1000ms
    /// - HTML/Markdown: 50-200ms
    pub fn convert<P: AsRef<Path>>(&self, path: P) -> Result<ConversionResult> {
        let path = path.as_ref();

        let start = Instant::now();

        // Check if we should use Rust backend for this format
        let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
        let format = InputFormat::from_extension(ext);

        // Handle DOC format specially: convert to DOCX first, then process with Python
        if format == Some(InputFormat::Doc) {
            let docx_path = crate::doc::convert_doc_to_docx(path)?;
            let result = self.convert_docx_after_doc(&docx_path, start)?;
            // Clean up temp file
            std::fs::remove_file(&docx_path).ok();
            return Ok(result);
        }

        let path_str = path
            .to_str()
            .ok_or_else(|| DoclingError::ConversionError("Invalid path".to_string()))?;

        // Check for USE_RUST_BACKEND environment variable
        let use_rust_backend = std::env::var("USE_RUST_BACKEND")
            .ok()
            .and_then(|v| v.parse::<bool>().ok().or_else(|| Some(v == "1")))
            .unwrap_or(false);

        // Route to Rust backend for supported formats if enabled
        if use_rust_backend {
            if let Some(fmt) = format {
                // Check if this format has Rust backend support
                let has_rust_support = fmt.is_ebook()
                    || fmt.is_archive()
                    || fmt.is_email()
                    || fmt.is_subtitle()
                    || fmt.is_video()
                    || fmt.is_audio()
                    || fmt.is_opendocument()
                    || fmt.is_apple()
                    || matches!(fmt, InputFormat::Xps);

                if has_rust_support {
                    return self.convert_with_rust_backend(path, start);
                }
            }
        }

        let (markdown, format, num_pages) = Python::attach(|py| {
            // Call: result = converter.convert(path)
            let result = self
                .py_converter
                .call_method1(py, "convert", (path_str,))
                .map_err(|e| DoclingError::PythonError(format!("Python convert() failed: {e}")))?;

            // Get document: result.document
            let py_document = result.getattr(py, "document").map_err(|e| {
                DoclingError::PythonError(format!("Failed to get document attribute: {e}"))
            })?;

            // Extract page count from document.pages if available
            let num_pages = py_document
                .getattr(py, "pages")
                .ok()
                .and_then(|pages| {
                    pages
                        .call_method0(py, "__len__")
                        .ok()
                        .and_then(|len| len.extract::<usize>(py).ok())
                })
                .filter(|&count| count > 0);

            // Call: markdown = document.export_to_markdown()
            let markdown_obj = py_document
                .call_method0(py, "export_to_markdown")
                .map_err(|e| {
                    DoclingError::PythonError(format!("Failed to export markdown: {e}"))
                })?;

            let markdown: String = markdown_obj.extract(py).map_err(|e| {
                DoclingError::PythonError(format!("Failed to extract markdown string: {e}"))
            })?;

            // Detect format from file extension
            let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
            let format = InputFormat::from_extension(ext)
                .ok_or_else(|| DoclingError::FormatError(format!("Unknown format: {ext}")))?;

            Ok::<_, DoclingError>((markdown, format, num_pages))
        })?;

        let latency = start.elapsed();

        let document = Document {
            markdown: markdown.clone(),
            format,
            metadata: DocumentMetadata {
                num_pages,
                num_characters: markdown.chars().count(),
                title: None,
                author: None,
                subject: None,
                created: None,
                modified: None,
                language: None,
                exif: None,
            },
            content_blocks: None, // Phase 0: No structured content yet
        };

        Ok(ConversionResult { document, latency })
    }

    /// Convert document using Rust backend (for e-books)
    fn convert_with_rust_backend<P: AsRef<Path>>(
        &self,
        path: P,
        start: Instant,
    ) -> Result<ConversionResult> {
        let path = path.as_ref();

        // Detect format
        let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
        let format = InputFormat::from_extension(ext)
            .ok_or_else(|| DoclingError::FormatError(format!("Unknown format: {ext}")))?;

        // Route to appropriate backend
        let markdown = match format {
            InputFormat::Epub => crate::ebook::process_epub(path)?,
            InputFormat::Fb2 => crate::ebook::process_fb2(path)?,
            InputFormat::Mobi => crate::ebook::process_mobi(path)?,
            InputFormat::Eml => crate::email::process_eml(path)?,
            InputFormat::Mbox => crate::email::process_mbox(path)?,
            InputFormat::Vcf => crate::email::process_vcf(path)?,
            InputFormat::Msg => crate::email::process_msg(path)?,
            InputFormat::Zip => crate::archive::process_zip(path, self)?,
            InputFormat::Tar => crate::archive::process_tar(path, self)?,
            InputFormat::SevenZ => crate::archive::process_7z(path, self)?,
            InputFormat::Rar => crate::archive::process_rar(path, self)?,
            InputFormat::Wav => crate::audio::process_wav(path)?,
            InputFormat::Mp3 => crate::audio::process_mp3(path)?,
            InputFormat::Mp4 => crate::video::process_mp4(path)?,
            InputFormat::Mkv => crate::video::process_mkv(path)?,
            InputFormat::Mov => crate::video::process_mov(path)?,
            InputFormat::Avi => crate::video::process_avi(path)?,
            InputFormat::Srt => crate::video::process_srt(path)?,
            InputFormat::Webvtt => crate::video::process_webvtt(path)?,
            InputFormat::Odt => crate::opendocument::process_odt(path)?,
            InputFormat::Ods => crate::opendocument::process_ods(path)?,
            InputFormat::Odp => crate::opendocument::process_odp(path)?,
            InputFormat::Xps => crate::xps::process_xps(path)?,
            InputFormat::Svg => crate::svg::process_svg(path)?,
            InputFormat::Ics => crate::calendar::process_ics(path)?,
            InputFormat::Ipynb => crate::notebook::process_ipynb(path)?,
            InputFormat::Gpx => crate::gps::process_gpx(path)?,
            InputFormat::Kml | InputFormat::Kmz => crate::kml::process_kml(path)?,
            InputFormat::Dicom => crate::dicom::process_dicom(path)?,
            // NOTE: Apple iWork formats now handled by docling-backend converter
            // See docling-backend/src/converter.rs for Pages, Numbers, Keynote
            InputFormat::Pages | InputFormat::Numbers | InputFormat::Key => {
                return Err(DoclingError::ConversionError(
                    "Apple iWork formats must use docling-backend converter, not docling-core converter".to_string()
                ))
            }
            _ => {
                return Err(DoclingError::ConversionError(format!(
                    "Rust backend does not support format: {format}"
                )))
            }
        };

        let latency = start.elapsed();

        let document = Document {
            markdown: markdown.clone(),
            format,
            metadata: DocumentMetadata {
                num_pages: None,
                num_characters: markdown.chars().count(),
                // Note: E-book metadata is extracted in backend (ebooks.rs)
                // This fallback path doesn't populate metadata for any format
                title: None,
                author: None,
                subject: None,
                created: None,
                modified: None,
                language: None,
                exif: None,
            },
            content_blocks: None,
        };

        Ok(ConversionResult { document, latency })
    }

    /// Convert a DOCX file that was converted from DOC
    ///
    /// This is a helper method to process DOCX files after DOC→DOCX conversion.
    /// It passes the DOCX file to Python's `DocX` backend and attributes the format as DOC.
    fn convert_docx_after_doc(&self, docx_path: &Path, start: Instant) -> Result<ConversionResult> {
        let path_str = docx_path
            .to_str()
            .ok_or_else(|| DoclingError::ConversionError("Invalid DOCX path".to_string()))?;

        let markdown = Python::attach(|py| {
            // Call: result = converter.convert(docx_path)
            let result = self
                .py_converter
                .call_method1(py, "convert", (path_str,))
                .map_err(|e| {
                    DoclingError::PythonError(format!(
                        "Python convert() failed for converted DOCX: {e}"
                    ))
                })?;

            // Get document: result.document
            let py_document = result.getattr(py, "document").map_err(|e| {
                DoclingError::PythonError(format!("Failed to get document attribute: {e}"))
            })?;

            // Call: markdown = document.export_to_markdown()
            let markdown_obj = py_document
                .call_method0(py, "export_to_markdown")
                .map_err(|e| {
                    DoclingError::PythonError(format!("Failed to export markdown: {e}"))
                })?;

            let markdown: String = markdown_obj.extract(py).map_err(|e| {
                DoclingError::PythonError(format!("Failed to extract markdown string: {e}"))
            })?;

            Ok::<_, DoclingError>(markdown)
        })?;

        let latency = start.elapsed();

        let document = Document {
            markdown: markdown.clone(),
            format: InputFormat::Doc, // Attribute as DOC, not DOCX
            metadata: DocumentMetadata {
                num_pages: None,
                num_characters: markdown.chars().count(),
                title: None,
                author: None,
                subject: None,
                created: None,
                modified: None,
                language: None,
                exif: None,
            },
            content_blocks: None,
        };

        Ok(ConversionResult { document, latency })
    }

    /// Convert multiple documents with streaming results (iterator pattern)
    ///
    /// This method mirrors Python docling's `convert_all()` API, accepting an iterator
    /// of document paths and returning an iterator of conversion results.
    ///
    /// # Features
    /// - **Lazy evaluation**: Documents are converted only when iterator is consumed
    /// - **Memory efficient**: Processes one document at a time
    /// - **Error handling**: Configurable via `ConversionConfig`
    /// - **Early termination**: Can break iteration on first error
    ///
    /// # Arguments
    /// * `paths` - Iterator of document paths to convert
    /// * `config` - Optional configuration (uses default if None)
    ///
    /// # Returns
    /// Iterator yielding `Result<ConversionResult>` for each document
    ///
    /// # Examples
    /// ```no_run
    /// use docling_core::DocumentConverter;
    ///
    /// let converter = DocumentConverter::new()?;
    /// let paths = vec!["doc1.pdf", "doc2.pdf", "doc3.pdf"];
    ///
    /// // Process all documents
    /// for result in converter.convert_all(paths, None) {
    ///     match result {
    ///         Ok(conv_result) => println!("Converted: {} chars", conv_result.document.markdown.len()),
    ///         Err(e) => eprintln!("Error: {}", e),
    ///     }
    /// }
    /// # Ok::<(), docling_core::DoclingError>(())
    /// ```
    ///
    /// # Python Source Reference
    /// Mirrors Python docling's `DocumentConverter.convert_all()`:
    /// - File: `~/docling/docling/document_converter.py`
    /// - Lines: 240-275
    /// - Behavior: Returns `Iterator[ConversionResult]`
    pub fn convert_all<P: AsRef<Path>>(
        &self,
        paths: impl IntoIterator<Item = P>,
        config: Option<ConversionConfig>,
    ) -> ConversionIterator<'_> {
        let config = config.unwrap_or_default();
        let paths: Vec<PathBuf> = paths
            .into_iter()
            .map(|p| p.as_ref().to_path_buf())
            .collect();

        ConversionIterator {
            converter: self,
            paths: paths.into_iter(),
            config,
            had_result: false,
        }
    }
}

/// Configuration for batch document conversion
///
/// Controls behavior of `convert_all()` method, mirroring Python docling's parameters.
///
/// # Examples
/// ```
/// use docling_core::ConversionConfig;
///
/// // Continue on errors
/// let config = ConversionConfig {
///     raises_on_error: false,
///     ..Default::default()
/// };
///
/// // Limit pages per document
/// let config = ConversionConfig {
///     max_num_pages: Some(10),
///     ..Default::default()
/// };
/// ```
///
/// # Python Source Reference
/// Mirrors Python docling's `convert_all()` parameters:
/// - `raises_on_error`: bool (True = stop on first error, False = continue)
/// - `max_num_pages`: int (sys.maxsize = no limit)
/// - `max_file_size`: int (sys.maxsize = no limit)
#[derive(Debug, Clone)]
pub struct ConversionConfig {
    /// If true, iteration stops on first error. If false, errors are yielded as `Err()` and iteration continues.
    pub raises_on_error: bool,

    /// Maximum number of pages to process per document (None = unlimited)
    pub max_num_pages: Option<usize>,

    /// Maximum file size in bytes (None = unlimited)
    pub max_file_size: Option<usize>,
}

impl Default for ConversionConfig {
    fn default() -> Self {
        Self {
            raises_on_error: true, // Match Python default
            max_num_pages: None,   // Python uses sys.maxsize (unlimited)
            max_file_size: None,   // Python uses sys.maxsize (unlimited)
        }
    }
}

/// Iterator over conversion results from `convert_all()`
///
/// Lazily converts documents one at a time, yielding results as they complete.
/// Implements the streaming pattern from Python docling's `convert_all()`.
pub struct ConversionIterator<'a> {
    converter: &'a DocumentConverter,
    paths: std::vec::IntoIter<PathBuf>,
    config: ConversionConfig,
    had_result: bool,
}

impl Iterator for ConversionIterator<'_> {
    type Item = Result<ConversionResult>;

    fn next(&mut self) -> Option<Self::Item> {
        let path = self.paths.next()?;

        // Check file size limit if configured
        if let Some(max_size) = self.config.max_file_size {
            if let Ok(metadata) = std::fs::metadata(&path) {
                if metadata.len() > max_size as u64 {
                    let err = DoclingError::ConversionError(format!(
                        "File size {} bytes exceeds limit {} bytes",
                        metadata.len(),
                        max_size
                    ));

                    if self.config.raises_on_error {
                        return Some(Err(err));
                    }
                    // Skip this file, continue to next
                    return self.next();
                }
            }
        }

        // Convert the document
        let result = self.converter.convert(&path);
        self.had_result = true;

        match result {
            Ok(conv_result) => Some(Ok(conv_result)),
            Err(e) => {
                if self.config.raises_on_error {
                    Some(Err(e))
                } else {
                    // Wrap error and continue
                    Some(Err(e))
                }
            }
        }
    }
}

impl Drop for ConversionIterator<'_> {
    fn drop(&mut self) {
        // Python raises ConversionError if no results and raises_on_error=True
        // We can't do this in Drop, but document the behavior
        // Users should check iterator.count() > 0 if they need this guarantee
    }
}

/// Result of a document conversion operation.
///
/// Contains the converted document along with performance metrics.
///
/// # Examples
///
/// ```rust,no_run
/// use docling_core::DocumentConverter;
///
/// let converter = DocumentConverter::new()?;
/// let result = converter.convert("document.pdf")?;

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::io::Write;
    use std::time::Duration;

    #[test]
    #[ignore] // Flaky: pyo3 may use different Python interpreter than system Python
    fn test_document_converter_creation() {
        // Test that we can create a converter
        // NOTE: This test is ignored because it's environment-dependent.
        // pyo3 may use a different Python interpreter that doesn't have docling installed.
        // The functionality is tested through integration tests instead.
        let result = DocumentConverter::new();
        assert!(
            result.is_ok(),
            "Failed to create DocumentConverter: {:?}",
            result.err()
        );
    }

    #[test]
    fn test_conversion_config_default() {
        let config = ConversionConfig::default();
        assert!(
            config.raises_on_error,
            "Default raises_on_error should be true"
        );
        assert_eq!(
            config.max_num_pages, None,
            "Default max_num_pages should be None"
        );
        assert_eq!(
            config.max_file_size, None,
            "Default max_file_size should be None"
        );
    }

    #[test]
    fn test_conversion_config_custom() {
        let config = ConversionConfig {
            raises_on_error: false,
            max_num_pages: Some(10),
            max_file_size: Some(1024 * 1024), // 1MB
        };

        assert!(!config.raises_on_error);
        assert_eq!(config.max_num_pages, Some(10));
        assert_eq!(config.max_file_size, Some(1024 * 1024));
    }

    #[test]
    #[ignore] // Requires Python docling installation
    fn test_convert_all_empty_iterator() {
        let converter = DocumentConverter::new().expect("Failed to create converter");
        let paths: Vec<&str> = vec![];

        let mut results = converter.convert_all(paths, None);
        assert!(
            results.next().is_none(),
            "Empty iterator should yield no results"
        );
    }

    #[test]
    #[ignore] // Requires Python docling installation
    fn test_convert_all_file_size_limit() {
        // Create a temporary file that exceeds the limit
        let temp_dir = std::env::temp_dir();
        let temp_file = temp_dir.join("test_large_file.txt");

        {
            let mut file = fs::File::create(&temp_file).expect("Failed to create temp file");
            // Write 2KB of data
            file.write_all(&vec![b'A'; 2048])
                .expect("Failed to write to temp file");
        }

        let converter = DocumentConverter::new().expect("Failed to create converter");

        // Set limit to 1KB
        let config = ConversionConfig {
            raises_on_error: true,
            max_file_size: Some(1024),
            max_num_pages: None,
        };

        let paths = vec![temp_file.clone()];
        let mut results = converter.convert_all(paths, Some(config));

        // Should get an error due to file size limit
        let result = results.next();
        assert!(result.is_some(), "Should get a result");
        assert!(
            result.unwrap().is_err(),
            "Should get an error for oversized file"
        );

        // Clean up
        fs::remove_file(&temp_file).ok();
    }

    #[test]
    #[ignore] // Requires Python docling installation
    fn test_convert_all_continues_on_error() {
        // Create two temp files: one valid markdown, one that doesn't exist
        let temp_dir = std::env::temp_dir();
        let valid_file = temp_dir.join("test_valid.md");
        let invalid_file = temp_dir.join("test_nonexistent.pdf");

        {
            let mut file = fs::File::create(&valid_file).expect("Failed to create temp file");
            file.write_all(b"# Test Document\n\nThis is a test.")
                .expect("Failed to write");
        }

        let converter = DocumentConverter::new().expect("Failed to create converter");

        // Configure to continue on errors
        let config = ConversionConfig {
            raises_on_error: false,
            max_file_size: None,
            max_num_pages: None,
        };

        let paths = vec![invalid_file, valid_file.clone()];
        let mut results = converter.convert_all(paths, Some(config));

        // First result should be an error (nonexistent file)
        let first_result = results.next();
        assert!(first_result.is_some(), "Should get first result");
        assert!(
            first_result.unwrap().is_err(),
            "First result should be error"
        );

        // Second result should be successful (valid markdown file)
        let second_result = results.next();
        assert!(second_result.is_some(), "Should get second result");
        // Note: Python bridge may not be available in unit tests, so this might fail
        // but the important part is that the iterator continues after first error

        // Clean up
        fs::remove_file(&valid_file).ok();
    }

    #[test]
    #[ignore] // Requires Python docling installation
    fn test_convert_all_iterator_lazy_evaluation() {
        // This test verifies that documents are converted lazily, not all at once
        let converter = DocumentConverter::new().expect("Failed to create converter");

        // Create 3 temp files
        let temp_dir = std::env::temp_dir();
        let files: Vec<_> = (0..3)
            .map(|i| {
                let path = temp_dir.join(format!("test_lazy_{}.md", i));
                {
                    let mut file = fs::File::create(&path).expect("Failed to create temp file");
                    file.write_all(format!("# Document {}\n", i).as_bytes())
                        .expect("Failed to write");
                }
                path
            })
            .collect();

        let config = ConversionConfig {
            raises_on_error: false,
            max_file_size: None,
            max_num_pages: None,
        };

        // Create iterator but don't consume it yet
        let mut results = converter.convert_all(files.clone(), Some(config));

        // Consume only first result
        let first = results.next();
        assert!(first.is_some(), "Should get first result");

        // Iterator should not have converted all files yet (lazy evaluation)
        // We can't directly test this without instrumentation, but we document the behavior

        // Clean up
        for file in files {
            fs::remove_file(&file).ok();
        }
    }

    #[test]
    #[ignore] // Requires Python docling installation
    fn test_convert_all_with_default_config() {
        let converter = DocumentConverter::new().expect("Failed to create converter");
        let paths: Vec<&str> = vec![];

        // None should use default config
        let mut results = converter.convert_all(paths, None);
        assert!(results.next().is_none());
    }

    // ===== N=649 Expansion: 7 additional tests =====

    #[test]
    fn test_conversion_config_max_pages_zero() {
        // Test that max_num_pages = 0 is valid (though semantically odd)
        let config = ConversionConfig {
            raises_on_error: false,
            max_file_size: None,
            max_num_pages: Some(0),
        };
        assert_eq!(config.max_num_pages, Some(0));
    }

    #[test]
    fn test_conversion_config_max_pages_large() {
        // Test that very large max_num_pages values are accepted
        let config = ConversionConfig {
            raises_on_error: true,
            max_file_size: Some(1_000_000_000), // 1GB
            max_num_pages: Some(999_999),       // Nearly 1 million pages
        };
        assert_eq!(config.max_num_pages, Some(999_999));
        assert_eq!(config.max_file_size, Some(1_000_000_000));
    }

    #[test]
    fn test_conversion_config_all_none() {
        // Test config with all optional fields as None
        let config = ConversionConfig {
            raises_on_error: false,
            max_file_size: None,
            max_num_pages: None,
        };
        assert!(!config.raises_on_error);
        assert_eq!(config.max_file_size, None);
        assert_eq!(config.max_num_pages, None);
    }

    #[test]
    fn test_conversion_config_raises_on_error_true() {
        // Test that raises_on_error = true is respected
        let config = ConversionConfig {
            raises_on_error: true,
            max_file_size: None,
            max_num_pages: None,
        };
        assert!(config.raises_on_error);
    }

    #[test]
    #[ignore] // Requires Python docling installation
    fn test_convert_all_single_file() {
        // Test converting a single file (simplest non-empty case)
        let converter = DocumentConverter::new().expect("Failed to create converter");

        // Create a single temp file
        let temp_dir = std::env::temp_dir();
        let file = temp_dir.join("test_single_file.md");
        {
            let mut f = fs::File::create(&file).expect("Failed to create temp file");
            f.write_all(b"# Single File Test\n")
                .expect("Failed to write");
        }

        let config = ConversionConfig {
            raises_on_error: false,
            max_file_size: None,
            max_num_pages: None,
        };

        let paths = vec![file.clone()];
        let mut results = converter.convert_all(paths, Some(config));

        // Should get exactly one result
        let first = results.next();
        assert!(first.is_some(), "Should get one result");

        let second = results.next();
        assert!(second.is_none(), "Should not get second result");

        // Clean up
        fs::remove_file(&file).ok();
    }

    #[test]
    #[ignore] // Requires Python docling installation
    fn test_convert_all_mixed_formats() {
        // Test converting multiple different file formats
        let converter = DocumentConverter::new().expect("Failed to create converter");

        let temp_dir = std::env::temp_dir();

        // Create files of different formats
        let md_file = temp_dir.join("test_mixed_1.md");
        fs::write(&md_file, b"# Markdown\n").expect("Failed to write markdown");

        let txt_file = temp_dir.join("test_mixed_2.txt");
        fs::write(&txt_file, b"Plain text\n").expect("Failed to write text");

        let config = ConversionConfig {
            raises_on_error: false,
            max_file_size: None,
            max_num_pages: None,
        };

        let paths = vec![md_file.clone(), txt_file.clone()];
        let mut results = converter.convert_all(paths, Some(config));

        // Should get two results (success or error for each)
        let first = results.next();
        assert!(first.is_some(), "Should get first result");

        let second = results.next();
        assert!(second.is_some(), "Should get second result");

        let third = results.next();
        assert!(third.is_none(), "Should not get third result");

        // Clean up
        fs::remove_file(&md_file).ok();
        fs::remove_file(&txt_file).ok();
    }

    #[test]
    fn test_conversion_config_file_size_boundary() {
        // Test file size limit at specific boundaries
        let config_1mb = ConversionConfig {
            raises_on_error: false,
            max_file_size: Some(1_048_576), // Exactly 1MB
            max_num_pages: None,
        };
        assert_eq!(config_1mb.max_file_size, Some(1_048_576));

        let config_100mb = ConversionConfig {
            raises_on_error: false,
            max_file_size: Some(104_857_600), // Exactly 100MB
            max_num_pages: None,
        };
        assert_eq!(config_100mb.max_file_size, Some(104_857_600));
    }

    #[test]
    fn test_conversion_result_save_markdown() {
        // Create a test document
        let doc = Document::from_markdown(
            "# Test Document\n\nThis is test content.".to_string(),
            InputFormat::Md,
        );

        let result = ConversionResult {
            document: doc,
            latency: Duration::from_millis(100),
        };

        // Save to temporary file
        let temp_dir = std::env::temp_dir();
        let temp_file = temp_dir.join("test_save_markdown.md");

        // Test save
        result
            .save_markdown(&temp_file)
            .expect("Failed to save markdown");

        // Verify content
        let content = fs::read_to_string(&temp_file).expect("Failed to read saved file");
        assert_eq!(content, "# Test Document\n\nThis is test content.");

        // Cleanup
        fs::remove_file(&temp_file).ok();
    }

    #[test]
    fn test_conversion_result_save_json() {
        // Create a test document with metadata
        let doc = Document {
            markdown: "# Test".to_string(),
            format: InputFormat::Md,
            metadata: DocumentMetadata {
                num_pages: Some(1),
                num_characters: 6,
                title: Some("Test Document".to_string()),
                author: Some("Test Author".to_string()),
                subject: None,
                created: None,
                modified: None,
                language: None,
                exif: None,
            },
            content_blocks: None,
        };

        let result = ConversionResult {
            document: doc,
            latency: Duration::from_millis(150),
        };

        // Save to temporary file
        let temp_dir = std::env::temp_dir();
        let temp_file = temp_dir.join("test_save_json.json");

        // Test save
        result.save_json(&temp_file).expect("Failed to save JSON");

        // Verify JSON is valid and contains expected fields
        let content = fs::read_to_string(&temp_file).expect("Failed to read saved file");
        let parsed: serde_json::Value = serde_json::from_str(&content).expect("Invalid JSON");

        assert_eq!(parsed["markdown"], "# Test");
        assert_eq!(parsed["format"], "MD");
        assert_eq!(parsed["metadata"]["num_characters"], 6);
        assert_eq!(parsed["metadata"]["num_pages"], 1);
        assert_eq!(parsed["metadata"]["title"], "Test Document");
        assert_eq!(parsed["metadata"]["author"], "Test Author");

        // Cleanup
        fs::remove_file(&temp_file).ok();
    }

    #[test]
    fn test_conversion_result_save_yaml() {
        // Create a test document with metadata
        let doc = Document {
            markdown: "# Test\n\nYAML test content.".to_string(),
            format: InputFormat::Md,
            metadata: DocumentMetadata {
                num_pages: Some(2),
                num_characters: 27,
                title: Some("YAML Test".to_string()),
                author: Some("Test Author".to_string()),
                subject: None,
                created: None,
                modified: None,
                language: None,
                exif: None,
            },
            content_blocks: None,
        };

        let result = ConversionResult {
            document: doc,
            latency: Duration::from_millis(200),
        };

        // Save to temporary file
        let temp_dir = std::env::temp_dir();
        let temp_file = temp_dir.join("test_save_yaml.yaml");

        // Test save
        result.save_yaml(&temp_file).expect("Failed to save YAML");

        // Verify YAML is valid and contains expected fields
        let content = fs::read_to_string(&temp_file).expect("Failed to read saved file");

        // Parse YAML back to Document to verify it's valid
        let parsed: Document = serde_yaml::from_str(&content).expect("Invalid YAML");

        assert_eq!(parsed.markdown, "# Test\n\nYAML test content.");
        assert_eq!(parsed.format, InputFormat::Md);
        assert_eq!(parsed.metadata.num_characters, 27);
        assert_eq!(parsed.metadata.num_pages, Some(2));
        assert_eq!(parsed.metadata.title, Some("YAML Test".to_string()));
        assert_eq!(parsed.metadata.author, Some("Test Author".to_string()));

        // Verify YAML is human-readable (has newlines and field names)
        assert!(content.contains("markdown:"));
        assert!(content.contains("format:"));
        assert!(content.contains("metadata:"));
        assert!(content.contains("YAML Test"));
        assert!(content.contains('\n'));

        // Cleanup
        fs::remove_file(&temp_file).ok();
    }

    #[test]
    fn test_conversion_result_stats() {
        // Create a test document
        let doc = Document::from_markdown(
            "# Title\n\nFirst paragraph with some words.\n\nSecond paragraph.".to_string(),
            InputFormat::Md,
        );

        let result = ConversionResult {
            document: doc,
            latency: Duration::from_millis(50),
        };

        // Get stats
        let stats = result.stats();

        // Verify stats
        assert_eq!(stats.num_characters, 60);
        assert!(stats.word_count > 0); // Should have several words
        assert!(stats.num_lines > 0); // Should have multiple lines
        assert_eq!(stats.num_pages, None); // No page info for markdown
        assert_eq!(stats.num_blocks, None); // No content blocks
    }
}
