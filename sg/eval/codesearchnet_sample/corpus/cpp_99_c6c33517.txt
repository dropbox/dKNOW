/**
               Give preference to cores that have large minimal values.
            */
            sort_assumptions(asms);
            unsigned last_index = 0;
            unsigned index = 0;
            SASSERT(index < asms.size() || asms.empty());
            IF_VERBOSE(10, verbose_stream() << "start hill climb " << index << " asms: " << asms.size() << "\n";);
            while (index < asms.size() && is_sat == l_true) {
                while (asms.size() > 20*(index - last_index) && index < asms.size()) {
                    index = next_index(asms, index);
                }
                last_index = index;
                is_sat = check_sat(index, asms.data());
            }
        }
        else {
            is_sat = check_sat(asms.size(), asms.data());
        }
        return is_sat;
    }

    lbool check_sat(unsigned sz, expr* const* asms) {
        lbool r = s().check_sat(sz, asms);
        if (r == l_true) {
            model_ref mdl;
            s().get_model(mdl);
            TRACE(opt, tout << *mdl;);
            if (mdl.get()) {
                update_assignment(mdl);
            }
        }
        return r;
    }

    void found_optimum() {
        IF_VERBOSE(1, verbose_stream() << "found optimum\n";);
        verify_assumptions();
        m_lower.reset();
        for (soft& s : m_soft) {
            s.set_value(m_model->is_true(s.s));
            if (!s.is_true()) {
                m_lower += s.weight;
            }
        }
        m_upper = m_lower;
        m_found_feasible_optimum = true;
    }


    lbool operator()() override {
        m_defs.reset();
        switch(m_st) {
        case s_primal:
        case s_primal_binary:
        case s_rc2:
        case s_primal_binary_rc2:
            return mus_solver();
        case s_primal_dual:
            return primal_dual_solver();
        }
        return l_undef;
    }

    void collect_statistics(statistics& st) const override {
        st.update("maxsat-cores", m_stats.m_num_cores);
        st.update("maxsat-correction-sets", m_stats.m_num_cs);
    }

    lbool get_cores(vector<weighted_core>& cores) {
        // assume m_s is unsat.
        lbool is_sat = l_false;
        cores.reset();
        exprs core;
        while (is_sat == l_false) {
            core.reset();
            expr_ref_vector _core(m);
            s().get_unsat_core(_core);
            model_ref mdl;
            get_mus_model(mdl);
            is_sat = minimize_core(_core);
            core.append(_core.size(), _core.data());
            DEBUG_CODE(verify_core(core););
            ++m_stats.m_num_cores;
            if (is_sat != l_true) {
                IF_VERBOSE(100, verbose_stream() << "(opt.maxres minimization failed)\n";);
                break;
            }
            if (core.empty()) {
                IF_VERBOSE(100, verbose_stream() << "(opt.maxres core is empty)\n";);
                TRACE(opt, tout << "empty core\n";);
                cores.reset();
                m_lower = m_upper;
                return l_true;
            }


            // 1. remove all core literals from m_asms
            // 2. re-add literals of higher weight than min-weight.
            // 3. 'core' stores the core literals that are
            //    re-encoded as assumptions, afterwards
            cores.push_back(weighted_core(core, core_weight(core)));

            remove_soft(core, m_asms);
            split_core(core);

            if (core.size() >= m_max_core_size)
                break;

            is_sat = check_sat_hill_climb(m_asms);
        }

        TRACE(opt,
              tout << "sat: " << is_sat << " num cores: " << cores.size() << "\n";
              for (auto const& c : cores) display_vec(tout, c.m_core);
              tout << "num assumptions: " << m_asms.size() << "\n";);

        return is_sat;
    }

    void get_current_correction_set(exprs& cs) {
        model_ref mdl;
        s().get_model(mdl);
        update_assignment(mdl);
        get_current_correction
  // ... truncated