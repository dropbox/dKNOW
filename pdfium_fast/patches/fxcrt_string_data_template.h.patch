--- pdfium/core/fxcrt/string_data_template.h	2025-11-20 14:44:25
+++ core/fxcrt/string_data_template.h	2025-12-03 16:39:54
@@ -10,6 +10,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include <atomic>
 #include <string>
 
 #include "core/fxcrt/retain_ptr.h"
@@ -23,11 +24,17 @@
   static RetainPtr<StringDataTemplate> Create(size_t nLen);
   static RetainPtr<StringDataTemplate> Create(pdfium::span<const CharType> str);
 
-  void Retain() { ++refs_; }
+  void Retain() {
+    // CRITICAL: Use atomic increment for thread-safe reference counting
+    // Required for parallel page rendering (FPDF_RenderPagesParallelV2)
+    refs_.fetch_add(1, std::memory_order_relaxed);
+  }
+
   void Release();
 
   bool CanOperateInPlace(size_t nTotalLen) const {
-    return refs_ <= 1 && nTotalLen <= alloc_length_;
+    // CRITICAL: Use atomic load for thread-safe reference count check
+    return refs_.load(std::memory_order_relaxed) <= 1 && nTotalLen <= alloc_length_;
   }
 
   void CopyContents(const StringDataTemplate& other);
@@ -87,7 +94,9 @@
   // Since the count increments with each new pointer, the largest value is
   // the number of pointers that can fit into the address space. The size of
   // the address space itself is a good upper bound on it.
-  intptr_t refs_ = 0;
+  //
+  // CRITICAL: Atomic for thread-safe reference counting in parallel rendering
+  mutable std::atomic<intptr_t> refs_{0};
 
   // These lengths are in terms of number of characters, not bytes, and do not
   // include the terminating NUL character, but the underlying buffer is sized
