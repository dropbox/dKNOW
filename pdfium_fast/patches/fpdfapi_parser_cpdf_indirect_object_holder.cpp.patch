--- pdfium/core/fpdfapi/parser/cpdf_indirect_object_holder.cpp	2025-11-20 14:44:25
+++ core/fpdfapi/parser/cpdf_indirect_object_holder.cpp	2025-12-03 16:39:54
@@ -42,6 +42,7 @@
 
 const CPDF_Object* CPDF_IndirectObjectHolder::GetIndirectObjectInternal(
     uint32_t objnum) const {
+  std::shared_lock<std::shared_mutex> lock(indirect_objs_mutex_);
   auto it = indirect_objs_.find(objnum);
   if (it == indirect_objs_.end()) {
     return nullptr;
@@ -61,13 +62,38 @@
     return nullptr;
   }
 
-  // Add item anyway to prevent recursively parsing of same object.
-  auto insert_result = indirect_objs_.insert(std::make_pair(objnum, nullptr));
-  if (!insert_result.second) {
+  // FAST PATH: Try shared_lock first for cache hits (allows concurrent reads)
+  // This is critical for parallel image rendering performance where all threads
+  // read objects concurrently.
+  {
+    std::shared_lock<std::shared_mutex> shared_lock(indirect_objs_mutex_);
+    auto it = indirect_objs_.find(objnum);
+    if (it != indirect_objs_.end()) {
+      // Object found in cache - return it without taking exclusive lock
+      return const_cast<CPDF_Object*>(
+          FilterInvalidObjNum(it->second.Get()));
+    }
+    // Object not found - fall through to slow path
+  }  // Release shared_lock before taking unique_lock
+
+  // SLOW PATH: Object not cached, need exclusive lock to parse and insert
+  std::unique_lock<std::shared_mutex> unique_lock(indirect_objs_mutex_);
+
+  // Double-check after upgrading lock (another thread may have loaded it)
+  auto it = indirect_objs_.find(objnum);
+  if (it != indirect_objs_.end()) {
     return const_cast<CPDF_Object*>(
-        FilterInvalidObjNum(insert_result.first->second.Get()));
+        FilterInvalidObjNum(it->second.Get()));
   }
+
+  // Add placeholder to prevent recursive parsing
+  auto insert_result = indirect_objs_.insert(std::make_pair(objnum, nullptr));
+
+  // Unlock during slow parsing operation (parsing doesn't need lock)
+  unique_lock.unlock();
   RetainPtr<CPDF_Object> pNewObj = ParseIndirectObject(objnum);
+  unique_lock.lock();
+
   if (!pNewObj) {
     indirect_objs_.erase(insert_result.first);
     return nullptr;
@@ -89,6 +115,7 @@
 uint32_t CPDF_IndirectObjectHolder::AddIndirectObject(
     RetainPtr<CPDF_Object> pObj) {
   CHECK(!pObj->GetObjNum());
+  std::unique_lock<std::shared_mutex> lock(indirect_objs_mutex_);
   pObj->SetObjNum(++last_obj_num_);
   indirect_objs_[last_obj_num_] = std::move(pObj);
   return last_obj_num_;
@@ -102,6 +129,7 @@
     return false;
   }
 
+  std::unique_lock<std::shared_mutex> lock(indirect_objs_mutex_);
   auto& obj_holder = indirect_objs_[objnum];
   const CPDF_Object* old_object = FilterInvalidObjNum(obj_holder.Get());
   if (old_object && pObj->GetGenNum() <= old_object->GetGenNum()) {
@@ -115,6 +143,7 @@
 }
 
 void CPDF_IndirectObjectHolder::DeleteIndirectObject(uint32_t objnum) {
+  std::unique_lock<std::shared_mutex> lock(indirect_objs_mutex_);
   auto it = indirect_objs_.find(objnum);
   if (it == indirect_objs_.end() || !FilterInvalidObjNum(it->second.Get())) {
     return;
