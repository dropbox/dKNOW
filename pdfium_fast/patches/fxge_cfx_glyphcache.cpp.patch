--- pdfium/core/fxge/cfx_glyphcache.cpp	2025-11-20 14:44:25
+++ core/fxge/cfx_glyphcache.cpp	2025-12-03 16:39:54
@@ -142,6 +142,18 @@
   bool vertical = pSubstFont && font->IsVertical();
   const PathMapKey key =
       std::make_tuple(glyph_index, dest_width, weight, angle, vertical);
+
+  // PARALLEL TEXT EXTRACTION: Lock-free read path after pre-warming
+  // After pre-warming, path_map_ is populated with all paths
+  // C++ ยง26.2.5.1 guarantees map::find() is thread-safe for concurrent reads
+  if (read_only_mode_.load(std::memory_order_acquire)) {
+    auto it = path_map_.find(key);
+    return it != path_map_.end() ? it->second.get() : nullptr;
+  }
+
+  // Thread-safety: Lock for map access (modification path)
+  std::lock_guard<std::mutex> lock(cache_mutex_);
+
   auto it = path_map_.find(key);
   if (it != path_map_.end()) {
     return it->second.get();
@@ -185,33 +197,37 @@
 #if BUILDFLAG(IS_APPLE)
   DCHECK(!CFX_DefaultRenderDevice::UseSkiaRenderer());
 
-  std::unique_ptr<CFX_GlyphBitmap> pGlyphBitmap;
-  auto it = size_map_.find(FaceGlyphsKey);
-  if (it != size_map_.end()) {
-    SizeGlyphCache* pSizeCache = &(it->second);
-    auto it2 = pSizeCache->find(glyph_index);
-    if (it2 != pSizeCache->end()) {
-      return it2->second.get();
-    }
+  // Thread-safety: Lock for size_map_ access (native text path)
+  {
+    std::lock_guard<std::mutex> lock(cache_mutex_);
+    std::unique_ptr<CFX_GlyphBitmap> pGlyphBitmap;
+    auto it = size_map_.find(FaceGlyphsKey);
+    if (it != size_map_.end()) {
+      SizeGlyphCache* pSizeCache = &(it->second);
+      auto it2 = pSizeCache->find(glyph_index);
+      if (it2 != pSizeCache->end()) {
+        return it2->second.get();
+      }
 
-    pGlyphBitmap = RenderGlyph_Nativetext(font, glyph_index, matrix, dest_width,
-                                          anti_alias);
-    if (pGlyphBitmap) {
-      CFX_GlyphBitmap* pResult = pGlyphBitmap.get();
-      (*pSizeCache)[glyph_index] = std::move(pGlyphBitmap);
-      return pResult;
-    }
-  } else {
-    pGlyphBitmap = RenderGlyph_Nativetext(font, glyph_index, matrix, dest_width,
-                                          anti_alias);
-    if (pGlyphBitmap) {
-      CFX_GlyphBitmap* pResult = pGlyphBitmap.get();
+      pGlyphBitmap = RenderGlyph_Nativetext(font, glyph_index, matrix, dest_width,
+                                            anti_alias);
+      if (pGlyphBitmap) {
+        CFX_GlyphBitmap* pResult = pGlyphBitmap.get();
+        (*pSizeCache)[glyph_index] = std::move(pGlyphBitmap);
+        return pResult;
+      }
+    } else {
+      pGlyphBitmap = RenderGlyph_Nativetext(font, glyph_index, matrix, dest_width,
+                                            anti_alias);
+      if (pGlyphBitmap) {
+        CFX_GlyphBitmap* pResult = pGlyphBitmap.get();
 
-      SizeGlyphCache cache;
-      cache[glyph_index] = std::move(pGlyphBitmap);
+        SizeGlyphCache cache;
+        cache[glyph_index] = std::move(pGlyphBitmap);
 
-      size_map_[FaceGlyphsKey] = std::move(cache);
-      return pResult;
+        size_map_[FaceGlyphsKey] = std::move(cache);
+        return pResult;
+      }
     }
   }
   UniqueKeyGen keygen2(font, matrix, dest_width, anti_alias,
@@ -228,6 +244,18 @@
                                   int dest_width,
                                   int weight) {
   const WidthMapKey key = std::make_tuple(glyph_index, dest_width, weight);
+
+  // PARALLEL TEXT EXTRACTION: Lock-free read path after pre-warming
+  // After pre-warming, width_map_ is populated with all widths
+  // C++ ยง26.2.5.1 guarantees map::find() is thread-safe for concurrent reads
+  if (read_only_mode_.load(std::memory_order_acquire)) {
+    auto it = width_map_.find(key);
+    return it != width_map_.end() ? it->second : 0;
+  }
+
+  // Thread-safety: Lock for map access (modification path)
+  std::lock_guard<std::mutex> lock(cache_mutex_);
+
   auto it = width_map_.find(key);
   if (it != width_map_.end()) {
     return it->second;
@@ -247,7 +275,9 @@
 
 // A singleton SkFontMgr which can be used to decode raw font data or
 // otherwise get access to system fonts.
-SkFontMgr* g_fontmgr = nullptr;
+// Thread-safe singleton - must be atomic to ensure memory visibility.
+// InitializeGlobals uses release-store, GetDeviceCache uses acquire-load.
+std::atomic<SkFontMgr*> g_fontmgr{nullptr};
 
 sk_sp<SkFontMgr> CreateSkiaFontManager() {
 #if defined(PDF_USE_SKIA_CUSTOM_FONT_MANAGER)
@@ -262,29 +292,39 @@
 
 // static
 void CFX_GlyphCache::InitializeGlobals() {
-  CHECK(!g_fontmgr);
+  CHECK(!g_fontmgr.load(std::memory_order_relaxed));
+  SkFontMgr* new_fontmgr;
 #if BUILDFLAG(IS_WIN)
-  g_fontmgr = SkFontMgr_New_DirectWrite().release();
+  new_fontmgr = SkFontMgr_New_DirectWrite().release();
 #elif BUILDFLAG(IS_APPLE)
-  g_fontmgr = SkFontMgr_New_CoreText(nullptr).release();
+  new_fontmgr = SkFontMgr_New_CoreText(nullptr).release();
 #else
   // This is a SkFontMgr which will use FreeType to decode font data.
-  g_fontmgr = CreateSkiaFontManager().release();
+  new_fontmgr = CreateSkiaFontManager().release();
 #endif
+  // Release-store: ensures all writes to new_fontmgr are visible
+  // before pointer becomes visible to other threads
+  g_fontmgr.store(new_fontmgr, std::memory_order_release);
 }
 
 // static
 void CFX_GlyphCache::DestroyGlobals() {
-  CHECK(g_fontmgr);
-  delete g_fontmgr;
-  g_fontmgr = nullptr;
+  // Relaxed ordering: destruction is single-threaded (library shutdown)
+  SkFontMgr* fontmgr = g_fontmgr.load(std::memory_order_relaxed);
+  CHECK(fontmgr);
+  delete fontmgr;
+  g_fontmgr.store(nullptr, std::memory_order_relaxed);
 }
 
 CFX_TypeFace* CFX_GlyphCache::GetDeviceCache(const CFX_Font* font) {
-  if (!typeface_ && g_fontmgr) {
-    pdfium::span<const uint8_t> span = font->GetFontSpan();
-    typeface_ = g_fontmgr->makeFromStream(
-        std::make_unique<SkMemoryStream>(span.data(), span.size()));
+  if (!typeface_) {
+    // Acquire-load: synchronizes with InitializeGlobals' release-store
+    SkFontMgr* fontmgr = g_fontmgr.load(std::memory_order_acquire);
+    if (fontmgr) {
+      pdfium::span<const uint8_t> span = font->GetFontSpan();
+      typeface_ = fontmgr->makeFromStream(
+          std::make_unique<SkMemoryStream>(span.data(), span.size()));
+    }
   }
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_APPLE)
   // If DirectWrite or CoreText didn't work, try a fallback font manager.
@@ -307,6 +347,23 @@
     bool bFontStyle,
     int dest_width,
     int anti_alias) {
+  // PARALLEL TEXT EXTRACTION: Lock-free read path after pre-warming
+  // After pre-warming, size_map_ is populated with all glyph bitmaps
+  // C++ ยง26.2.5.1 guarantees map::find() is thread-safe for concurrent reads
+  if (read_only_mode_.load(std::memory_order_acquire)) {
+    auto it = size_map_.find(FaceGlyphsKey);
+    if (it != size_map_.end()) {
+      auto it2 = it->second.find(glyph_index);
+      if (it2 != it->second.end()) {
+        return it2->second.get();
+      }
+    }
+    return nullptr;  // Cache miss in read-only mode
+  }
+
+  // Thread-safety: Lock for map access (modification path)
+  std::lock_guard<std::mutex> lock(cache_mutex_);
+
   SizeGlyphCache* pSizeCache;
   auto it = size_map_.find(FaceGlyphsKey);
   if (it == size_map_.end()) {
