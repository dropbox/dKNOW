--- pdfium/core/fpdfapi/render/cpdf_rendertiling.cpp	2025-11-20 14:44:25
+++ core/fpdfapi/render/cpdf_rendertiling.cpp	2025-12-03 16:39:54
@@ -32,7 +32,8 @@
     const CFX_Matrix& mtObject2Device,
     int width,
     int height,
-    const CPDF_RenderOptions::Options& draw_options) {
+    const CPDF_RenderOptions::Options& draw_options,
+    CPDF_RenderStatus* pRenderStatus) {
   auto pBitmap = pdfium::MakeRetain<CFX_DIBitmap>();
   // TODO(crbug.com/42271020): Consider adding support for
   // `FXDIB_Format::kBgraPremul`
@@ -61,8 +62,10 @@
   options.GetOptions().bForceHalftone = true;
 
   CPDF_RenderContext context(doc, nullptr, pCache);
-  context.AppendLayer(pPatternForm, mtPattern2Bitmap);
-  context.Render(&bitmap_device, nullptr, &options, nullptr);
+  CPDF_RenderStatus status(&context, &bitmap_device);
+  status.SetOptions(options);
+  status.Initialize(pRenderStatus, nullptr);
+  status.RenderObjectList(pPatternForm, mtPattern2Bitmap);
 
   return pBitmap;
 }
@@ -135,6 +138,16 @@
 
     RetainPtr<const CPDF_Dictionary> pFormResource =
         pPatternForm->GetDict()->GetDictFor("Resources");
+
+    // Sanity check on tile counts to prevent pathological loops
+    int64_t col_count = static_cast<int64_t>(max_col) - static_cast<int64_t>(min_col) + 1;
+    int64_t row_count = static_cast<int64_t>(max_row) - static_cast<int64_t>(min_row) + 1;
+    const int64_t kMaxReasonableDimension = 1000;
+    if (col_count <= 0 || row_count <= 0 ||
+        col_count > kMaxReasonableDimension || row_count > kMaxReasonableDimension) {
+      return nullptr;
+    }
+
     for (int col = min_col; col <= max_col; col++) {
       for (int row = min_row; row <= max_row; row++) {
         CFX_PointF original = mtPattern2Device.Transform(
@@ -189,13 +202,13 @@
   if (width * height < 16) {
     RetainPtr<CFX_DIBitmap> pEnlargedBitmap = DrawPatternBitmap(
         context->GetDocument(), context->GetPageCache(), pPattern, pPatternForm,
-        mtObj2Device, 8, 8, options.GetOptions());
+        mtObj2Device, 8, 8, options.GetOptions(), pRenderStatus);
     pPatternBitmap = pEnlargedBitmap->StretchTo(
         width, height, FXDIB_ResampleOptions(), nullptr);
   } else {
     pPatternBitmap = DrawPatternBitmap(
         context->GetDocument(), context->GetPageCache(), pPattern, pPatternForm,
-        mtObj2Device, width, height, options.GetOptions());
+        mtObj2Device, width, height, options.GetOptions(), pRenderStatus);
   }
   if (!pPatternBitmap) {
     return nullptr;
@@ -213,6 +226,24 @@
     return nullptr;
   }
 
+  // Sanity check on tile counts to prevent pathological loops
+  // Calculate total tiles safely using 64-bit arithmetic
+  int64_t col_count = static_cast<int64_t>(max_col) - static_cast<int64_t>(min_col) + 1;
+  int64_t row_count = static_cast<int64_t>(max_row) - static_cast<int64_t>(min_row) + 1;
+
+  // Reasonable limits for tiling patterns (check each dimension separately to avoid overflow)
+  const int64_t kMaxReasonableDimension = 1000;  // Max tiles in any single dimension
+
+  // Check for negative, zero, or pathological counts
+  if (col_count <= 0 || row_count <= 0) {
+    return nullptr;
+  }
+
+  // Check each dimension independently to avoid overflow in multiplication
+  if (col_count > kMaxReasonableDimension || row_count > kMaxReasonableDimension) {
+    return nullptr;
+  }
+
   pdfium::span<const uint8_t> src_buf = pPatternBitmap->GetBuffer();
   for (int col = min_col; col <= max_col; col++) {
     for (int row = min_row; row <= max_row; row++) {
