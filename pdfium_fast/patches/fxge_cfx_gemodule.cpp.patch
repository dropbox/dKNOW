--- pdfium/core/fxge/cfx_gemodule.cpp	2025-11-20 14:44:25
+++ core/fxge/cfx_gemodule.cpp	2025-12-03 16:39:54
@@ -6,6 +6,9 @@
 
 #include "core/fxge/cfx_gemodule.h"
 
+#include <atomic>
+#include <mutex>
+
 #include "core/fxcrt/check.h"
 #include "core/fxge/cfx_folderfontinfo.h"
 #include "core/fxge/cfx_fontcache.h"
@@ -13,8 +16,17 @@
 
 namespace {
 
-CFX_GEModule* g_pGEModule = nullptr;
+// Thread-safe singleton state
+// Must be atomic to ensure memory visibility across threads.
+std::atomic<CFX_GEModule*> g_pGEModule{nullptr};
 
+// Returns the mutex for protecting CFX_GEModule singleton.
+// Using function-local static to avoid global constructor/destructor warnings.
+std::mutex& GetGEModuleMutex() {
+  static std::mutex mutex;
+  return mutex;
+}
+
 }  // namespace
 
 CFX_GEModule::CFX_GEModule(const char** pUserFontPaths)
@@ -27,22 +39,44 @@
 
 // static
 void CFX_GEModule::Create(const char** pUserFontPaths) {
-  DCHECK(!g_pGEModule);
-  g_pGEModule = new CFX_GEModule(pUserFontPaths);
-  g_pGEModule->platform_->Init();
-  g_pGEModule->GetFontMgr()->GetBuiltinMapper()->SetSystemFontInfo(
-      g_pGEModule->platform_->CreateDefaultSystemFontInfo());
+  std::lock_guard<std::mutex> lock(GetGEModuleMutex());
+
+  // Double-check pattern: module might have been created by another thread
+  // Use relaxed load inside mutex - mutex provides synchronization
+  if (g_pGEModule.load(std::memory_order_relaxed)) {
+    return;
+  }
+
+  CFX_GEModule* new_module = new CFX_GEModule(pUserFontPaths);
+  new_module->platform_->Init();
+
+  // Release-store: ensures all writes above are visible to threads that acquire-load
+  g_pGEModule.store(new_module, std::memory_order_release);
+
+  new_module->GetFontMgr()->GetBuiltinMapper()->SetSystemFontInfo(
+      new_module->platform_->CreateDefaultSystemFontInfo());
 }
 
 // static
 void CFX_GEModule::Destroy() {
-  DCHECK(g_pGEModule);
-  delete g_pGEModule;
-  g_pGEModule = nullptr;
+  std::lock_guard<std::mutex> lock(GetGEModuleMutex());
+
+  // Use relaxed load inside mutex - mutex provides synchronization
+  CFX_GEModule* module = g_pGEModule.load(std::memory_order_relaxed);
+  if (!module) {
+    return;
+  }
+
+  delete module;
+  // Relaxed store inside mutex is sufficient
+  g_pGEModule.store(nullptr, std::memory_order_relaxed);
 }
 
 // static
 CFX_GEModule* CFX_GEModule::Get() {
-  DCHECK(g_pGEModule);
-  return g_pGEModule;
+  // Fast path: no lock needed for read-only access after initialization.
+  // Acquire-load ensures we see all writes made by Create() before the release-store.
+  CFX_GEModule* module = g_pGEModule.load(std::memory_order_acquire);
+  DCHECK(module);
+  return module;
 }
