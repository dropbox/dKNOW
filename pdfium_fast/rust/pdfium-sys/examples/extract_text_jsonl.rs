use pdfium_sys::*;
use std::env;
use std::ffi::CString;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::process;

/// Extract text with character-level metadata in JSONL format.
///
/// Each line is a JSON object containing:
/// - char: Unicode character
/// - unicode: Unicode codepoint value
/// - bbox: Bounding box [left, bottom, right, top]
/// - origin: Character origin [x, y]
/// - font_size: Font size in points
/// - font_name: Font name
/// - font_weight: Font weight (100-900)
/// - fill_color: Fill color [R, G, B, A]
/// - stroke_color: Stroke color [R, G, B, A]
/// - angle: Rotation angle in radians
/// - matrix: Transformation matrix [a, b, c, d, e, f]
/// - is_generated: Whether character was generated by PDFium
/// - is_hyphen: Whether character is a hyphen
/// - has_unicode_error: Whether character has unicode mapping error
fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 3 || args.len() > 4 {
        eprintln!(
            "Usage: {} <input.pdf> <output.jsonl> [page_number]",
            args[0]
        );
        eprintln!("  page_number: Extract single page (0-indexed, default: page 0 only)");
        process::exit(1);
    }

    let pdf_path = &args[1];
    let output_path = &args[2];
    let page_num = if args.len() == 4 {
        args[3].parse::<i32>().unwrap_or_else(|_| {
            eprintln!("Error: page_number must be a non-negative integer");
            process::exit(1);
        })
    } else {
        0 // Default to page 0 only
    };

    if !Path::new(pdf_path).exists() {
        eprintln!("Error: PDF file not found: {}", pdf_path);
        process::exit(1);
    }

    match extract_text_jsonl(pdf_path, output_path, page_num) {
        Ok(_) => {
            eprintln!("JSONL extraction complete: {}", output_path);
            process::exit(0);
        }
        Err(e) => {
            eprintln!("Error: {}", e);
            process::exit(1);
        }
    }
}

fn extract_text_jsonl(pdf_path: &str, output_path: &str, page_num: i32) -> Result<(), String> {
    unsafe {
        FPDF_InitLibrary();

        // Load document
        let c_path = CString::new(pdf_path).unwrap();
        let doc = FPDF_LoadDocument(c_path.as_ptr(), std::ptr::null());
        if doc.is_null() {
            FPDF_DestroyLibrary();
            return Err(format!("Failed to load PDF: {}", pdf_path));
        }

        // Get page count
        let page_count = FPDF_GetPageCount(doc);
        if page_num < 0 || page_num >= page_count {
            FPDF_CloseDocument(doc);
            FPDF_DestroyLibrary();
            return Err(format!(
                "Invalid page number {} (document has {} pages)",
                page_num, page_count
            ));
        }

        // Open output file
        let mut output_file = File::create(output_path)
            .map_err(|e| format!("Failed to create output file: {}", e))?;

        // Load page
        let page = FPDF_LoadPage(doc, page_num);
        if page.is_null() {
            FPDF_CloseDocument(doc);
            FPDF_DestroyLibrary();
            return Err(format!("Failed to load page {}", page_num));
        }

        // Load text page
        let text_page = FPDFText_LoadPage(page);
        if text_page.is_null() {
            FPDF_ClosePage(page);
            FPDF_CloseDocument(doc);
            FPDF_DestroyLibrary();
            return Err(format!("Failed to load text for page {}", page_num));
        }

        let char_count = FPDFText_CountChars(text_page);
        eprintln!(
            "Extracting {} characters from page {}",
            char_count, page_num
        );

        // Extract each character with metadata
        let mut i = 0;
        while i < char_count {
            // 1. Get Unicode character
            let unicode = FPDFText_GetUnicode(text_page, i);

            // Handle UTF-16 surrogate pairs
            let (codepoint, chars_consumed) = if (0xD800..=0xDBFF).contains(&unicode) {
                // High surrogate - need to read low surrogate
                if i + 1 < char_count {
                    let low = FPDFText_GetUnicode(text_page, i + 1);
                    if (0xDC00..=0xDFFF).contains(&low) {
                        // Valid surrogate pair
                        let high = unicode;
                        let codepoint = ((high - 0xD800) << 10) + (low - 0xDC00) + 0x10000;
                        (codepoint, 2)
                    } else {
                        // Invalid surrogate pair - use replacement character
                        (0xFFFD, 1)
                    }
                } else {
                    // High surrogate at end of text - invalid
                    (0xFFFD, 1)
                }
            } else {
                (unicode, 1)
            };

            let char_value = std::char::from_u32(codepoint).unwrap_or('ï¿½');

            // 2. Get bounding box
            let mut left: f64 = 0.0;
            let mut right: f64 = 0.0;
            let mut bottom: f64 = 0.0;
            let mut top: f64 = 0.0;
            FPDFText_GetCharBox(text_page, i, &mut left, &mut right, &mut bottom, &mut top);

            // 3. Get origin
            let mut origin_x: f64 = 0.0;
            let mut origin_y: f64 = 0.0;
            FPDFText_GetCharOrigin(text_page, i, &mut origin_x, &mut origin_y);

            // 4. Get font size
            let font_size = FPDFText_GetFontSize(text_page, i);

            // 5. Get font info (name and flags)
            let font_name_len =
                FPDFText_GetFontInfo(text_page, i, std::ptr::null_mut(), 0, std::ptr::null_mut());
            let mut font_name = String::from("unknown");
            let mut font_flags: u32 = 0;
            if font_name_len > 0 {
                let mut buffer: Vec<u8> = vec![0; font_name_len as usize];
                FPDFText_GetFontInfo(
                    text_page,
                    i,
                    buffer.as_mut_ptr() as *mut _,
                    font_name_len,
                    &mut font_flags as *mut u32 as *mut i32,
                );
                // Remove trailing nulls
                while buffer.last() == Some(&0) {
                    buffer.pop();
                }
                if let Ok(name) = String::from_utf8(buffer) {
                    font_name = name;
                }
            }

            // 6. Get font weight
            let font_weight = FPDFText_GetFontWeight(text_page, i);

            // 7. Get fill color
            let mut fill_r: u32 = 0;
            let mut fill_g: u32 = 0;
            let mut fill_b: u32 = 0;
            let mut fill_a: u32 = 0;
            FPDFText_GetFillColor(
                text_page,
                i,
                &mut fill_r,
                &mut fill_g,
                &mut fill_b,
                &mut fill_a,
            );

            // 8. Get stroke color
            let mut stroke_r: u32 = 0;
            let mut stroke_g: u32 = 0;
            let mut stroke_b: u32 = 0;
            let mut stroke_a: u32 = 0;
            FPDFText_GetStrokeColor(
                text_page,
                i,
                &mut stroke_r,
                &mut stroke_g,
                &mut stroke_b,
                &mut stroke_a,
            );

            // 9. Get rotation angle
            let angle = FPDFText_GetCharAngle(text_page, i);

            // 10. Get transformation matrix
            let mut matrix = FS_MATRIX {
                a: 0.0,
                b: 0.0,
                c: 0.0,
                d: 0.0,
                e: 0.0,
                f: 0.0,
            };
            FPDFText_GetMatrix(text_page, i, &mut matrix);

            // 11. Check if generated
            let is_generated = FPDFText_IsGenerated(text_page, i) == 1;

            // 12. Check if hyphen
            let is_hyphen = FPDFText_IsHyphen(text_page, i) == 1;

            // 13. Check for unicode mapping error
            let has_unicode_error = FPDFText_HasUnicodeMapError(text_page, i) == 1;

            // Escape special characters in JSON string
            let char_escaped = match char_value {
                '"' => "\\\"".to_string(),
                '\\' => "\\\\".to_string(),
                '\n' => "\\n".to_string(),
                '\r' => "\\r".to_string(),
                '\t' => "\\t".to_string(),
                c if c.is_control() => format!("\\u{:04x}", c as u32),
                c => c.to_string(),
            };

            let font_name_escaped = font_name.replace("\\", "\\\\").replace("\"", "\\\"");

            // Write JSON line
            let json_line = format!(
                "{{\"char\":\"{}\",\"unicode\":{},\"bbox\":[{},{},{},{}],\"origin\":[{},{}],\"font_size\":{},\"font_name\":\"{}\",\"font_flags\":{},\"font_weight\":{},\"fill_color\":[{},{},{},{}],\"stroke_color\":[{},{},{},{}],\"angle\":{},\"matrix\":[{},{},{},{},{},{}],\"is_generated\":{},\"is_hyphen\":{},\"has_unicode_error\":{}}}\n",
                char_escaped,
                codepoint,
                left, bottom, right, top,
                origin_x, origin_y,
                font_size,
                font_name_escaped,
                font_flags,
                font_weight,
                fill_r, fill_g, fill_b, fill_a,
                stroke_r, stroke_g, stroke_b, stroke_a,
                angle,
                matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f,
                is_generated,
                is_hyphen,
                has_unicode_error
            );

            output_file
                .write_all(json_line.as_bytes())
                .map_err(|e| format!("Failed to write output: {}", e))?;

            i += chars_consumed;
        }

        // Cleanup
        FPDFText_ClosePage(text_page);
        FPDF_ClosePage(page);
        FPDF_CloseDocument(doc);
        FPDF_DestroyLibrary();

        Ok(())
    }
}
