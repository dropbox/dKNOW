"""
Tests for edinet_2025-06-24_1548_E01914_Not Registered in English.pdf

Generated by: lib/generate_test_files.py
DO NOT EDIT - Regenerate with: python lib/generate_test_files.py

PDF: edinet_2025-06-24_1548_E01914_Not Registered in English.pdf
Category: benchmark
Size: unknown (unknown pages)
Markers: full,batch_bulk,edinet

Test Strategy:
- Uses C++ CLI tool (pdfium_cli) with bulk mode (auto-dispatch strategy)
- Text: Extraction to temp file using 'extract-text', then compare with expected
- JSONL: Extract rich metadata using Rust tool, compare with expected
- Images: Validated in test_005_image_correctness.py (not duplicated per PDF)
"""

import pytest
from pathlib import Path
import tempfile
import subprocess
import json
import hashlib
import os

PDF_NAME = "edinet_2025-06-24_1548_E01914_Not Registered in English.pdf"
PDF_STEM = "edinet_2025-06-24_1548_E01914_Not Registered in English"
PDF_REL_PATH = "edinet_2025-06-24_1548_E01914_Not Registered in English.pdf"
EXPECTED_DIR = Path(__file__).parent.parent.parent.parent / "master_test_suite" / "expected_outputs" / "edinet" / "edinet_2025-06-24_1548_E01914_Not Registered in English"


def compute_md5(file_path):
    """Compute MD5 hash of file"""
    md5 = hashlib.md5()
    with open(file_path, 'rb') as f:
        while chunk := f.read(8192):
            md5.update(chunk)
    return md5.hexdigest()


@pytest.mark.full
@pytest.mark.batch_bulk
@pytest.mark.edinet
def test_text_extraction_edinet_2025_06_24_1548_E01914_Not_Registered_in_English(benchmark_pdfs, extract_text_tool_dispatcher, optimized_lib, expected_outputs):
    """Text extraction correctness for edinet_2025-06-24_1548_E01914_Not Registered in English.pdf"""
    pdf_path = benchmark_pdfs / PDF_REL_PATH
    manifest_path = EXPECTED_DIR / "manifest.json"

    assert pdf_path.exists(), f"PDF not found: {pdf_path}"
    assert manifest_path.exists(), f"Manifest not found: {manifest_path}"

    # Load manifest
    with open(manifest_path) as f:
        manifest = json.load(f)

    # Check for error manifest (unloadable PDF)
    if manifest.get("load_result") == "FPDF_LOAD_FAILED":
        # Validate that extraction fails gracefully
        env = os.environ.copy()
        env['DYLD_LIBRARY_PATH'] = str(optimized_lib.parent)

        with tempfile.NamedTemporaryFile(suffix='.txt', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            result = subprocess.run(
                [str(extract_text_tool_dispatcher), "--encoding", "utf32le", "extract-text", str(pdf_path), str(tmp_path)],
                capture_output=True,
                env=env,
                timeout=600
            )
            # Validate graceful failure
            assert result.returncode != 0, "Expected non-zero exit code for unloadable PDF"
            stderr_text = result.stderr.decode()
            assert ("Failed to load PDF" in stderr_text or "Failed to read page count" in stderr_text),                 "Expected load failure message"
        finally:
            if tmp_path.exists():
                tmp_path.unlink()

        # Test passed - validated graceful failure handling
        return

    # Check for 0-page PDF (loads successfully but should handle gracefully)
    if manifest.get("pdf_pages") == 0:
        # Test graceful handling of 0-page PDF
        env = os.environ.copy()
        env['DYLD_LIBRARY_PATH'] = str(optimized_lib.parent)

        with tempfile.NamedTemporaryFile(suffix='.txt', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            result = subprocess.run(
                [str(extract_text_tool_dispatcher), "--encoding", "utf32le", "extract-text", str(pdf_path), str(tmp_path)],
                capture_output=True,
                env=env,
                timeout=600
            )
            assert result.returncode == 0, f"Should handle 0-page PDF gracefully: {result.stderr.decode()}"
            # C++ CLI outputs UTF-32 LE BOM (4 bytes) for empty text
            assert tmp_path.stat().st_size == 4, "Should produce 4-byte BOM for 0-page PDF"
        finally:
            if tmp_path.exists():
                tmp_path.unlink()

        # Test passed - validated graceful 0-page handling
        return

    # Set up environment for shared library
    env = os.environ.copy()
    env['DYLD_LIBRARY_PATH'] = str(optimized_lib.parent)

    # Act: Extract text using C++ CLI tool (bulk mode, auto-dispatch)
    # Use UTF-32LE encoding to match baseline format (v2.0.0 defaults to UTF-8)
    with tempfile.NamedTemporaryFile(suffix='.txt', delete=False) as tmp:
        tmp_path = Path(tmp.name)

    try:
        result = subprocess.run(
            [str(extract_text_tool_dispatcher), "--encoding", "utf32le", "extract-text", str(pdf_path), str(tmp_path)],
            capture_output=True,
            env=env,
            timeout=600
        )
        assert result.returncode == 0, f"Extraction failed: {result.stderr.decode()}"

        # Read actual output
        actual_text = tmp_path.read_bytes()
    finally:
        # Clean up temp file
        if tmp_path.exists():
            tmp_path.unlink()

    # Assert: Compare with expected full text
    expected_full_path = EXPECTED_DIR / manifest["text"]["full"]["path"]
    expected_text = expected_full_path.read_bytes()

    assert actual_text == expected_text, f"Text mismatch for {PDF_NAME}"


@pytest.mark.full
@pytest.mark.batch_bulk
@pytest.mark.edinet
def test_jsonl_extraction_edinet_2025_06_24_1548_E01914_Not_Registered_in_English(benchmark_pdfs, optimized_lib, expected_outputs, pdfium_root):
    """JSONL extraction for edinet_2025-06-24_1548_E01914_Not Registered in English.pdf (page 0 only)"""
    pdf_path = benchmark_pdfs / PDF_REL_PATH
    manifest_path = EXPECTED_DIR / "manifest.json"

    assert pdf_path.exists(), f"PDF not found: {pdf_path}"
    assert manifest_path.exists(), f"Manifest not found: {manifest_path}"

    # Load manifest
    with open(manifest_path) as f:
        manifest = json.load(f)

    # Find extract_text_jsonl binary
    extract_jsonl_bin = pdfium_root / 'rust' / 'target' / 'release' / 'examples' / 'extract_text_jsonl'

    # Set up environment for shared library
    env = os.environ.copy()
    env['DYLD_LIBRARY_PATH'] = str(optimized_lib.parent)

    # Check for error manifest (unloadable PDF) - TEST graceful failure
    if manifest.get("load_result") == "FPDF_LOAD_FAILED":
        # JSONL extraction should fail gracefully for unloadable PDFs
        # This tests error handling, not a skip
        with tempfile.NamedTemporaryFile(suffix='.jsonl', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            result = subprocess.run(
                [str(extract_jsonl_bin), str(pdf_path), str(tmp_path), '0'],
                capture_output=True,
                env=env,
                timeout=600
            )
            # Validate graceful failure
            assert result.returncode != 0, "Expected non-zero exit code for unloadable PDF"
            stderr_text = result.stderr.decode()
            assert ("Failed to load PDF" in stderr_text or "Failed to read page count" in stderr_text), \
                "Expected load failure message"
        finally:
            if tmp_path.exists():
                tmp_path.unlink()

        # Test passed - validated graceful failure handling
        return

    # Check if JSONL is available for this PDF (0-page PDFs) - TEST graceful handling
    if not manifest["jsonl"]["pages"]:
        # For 0-page PDFs, JSONL should produce empty output or fail gracefully
        # This tests edge case handling, not a skip
        with tempfile.NamedTemporaryFile(suffix='.jsonl', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            result = subprocess.run(
                [str(extract_jsonl_bin), str(pdf_path), str(tmp_path), '0'],
                capture_output=True,
                env=env,
                timeout=600
            )
            # For 0-page PDFs, extraction might fail or produce empty output
            # Either is acceptable graceful behavior
            if result.returncode != 0:
                # Failed gracefully (expected for 0-page)
                pass
            else:
                # Succeeded with empty output (also acceptable)
                assert tmp_path.stat().st_size == 0, "Should produce empty JSONL for 0-page PDF"
        finally:
            if tmp_path.exists():
                tmp_path.unlink()

        # Test passed - validated graceful 0-page handling
        return

    # Check if JSONL baseline file actually exists on disk
    expected_jsonl_path = EXPECTED_DIR / manifest["jsonl"]["pages"][0]["path"]
    if not expected_jsonl_path.exists():
        pytest.skip(f"JSONL baseline not found: {expected_jsonl_path}")

    # Normal case: Extract JSONL for page 0
    with tempfile.NamedTemporaryFile(suffix='.jsonl', delete=False) as tmp:
        tmp_path = Path(tmp.name)

    try:
        result = subprocess.run(
            [str(extract_jsonl_bin), str(pdf_path), str(tmp_path), '0'],
            capture_output=True,
            env=env,
            timeout=600
        )
        assert result.returncode == 0, f"JSONL extraction failed: {result.stderr.decode()}"

        # Read actual output
        actual_jsonl = tmp_path.read_bytes()
    finally:
        # Clean up temp file
        if tmp_path.exists():
            tmp_path.unlink()

    # Assert: Compare with expected JSONL
    expected_jsonl = expected_jsonl_path.read_bytes()

    assert actual_jsonl == expected_jsonl, "JSONL mismatch on page 0"
