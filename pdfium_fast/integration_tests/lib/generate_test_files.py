#!/usr/bin/env python3
"""
Generate static test files for benchmark PDFs.

Output: tests/pdfs/<category>/test_<pdf_stem>.py
Each file: 2 test functions (text, jsonl)
Image correctness is validated in test_005_image_correctness.py

JSONL tests validate rich metadata (character positions, bounding boxes, fonts)

Run: python lib/generate_test_files.py
"""

import csv
import json
from pathlib import Path
import sys


# Template for test file with 3 test functions
# Uses Rust tools matching baseline generation
TEMPLATE = '''"""
Tests for {pdf_name}

Generated by: lib/generate_test_files.py
DO NOT EDIT - Regenerate with: python lib/generate_test_files.py

PDF: {pdf_name}
Category: {category}
Size: {size_class} ({pages} pages)
Markers: {markers}

Test Strategy:
- Uses C++ CLI tool (pdfium_cli) with bulk mode (auto-dispatch strategy)
- Text: Extraction to temp file using 'extract-text', then compare with expected
- JSONL: Extract rich metadata using Rust tool, compare with expected
- Images: Validated in test_005_image_correctness.py (not duplicated per PDF)
"""

import pytest
from pathlib import Path
import tempfile
import subprocess
import json
import hashlib
import os

PDF_NAME = "{pdf_name}"
PDF_STEM = "{pdf_stem}"
PDF_REL_PATH = "{rel_path}"
EXPECTED_DIR = Path(__file__).parent.parent.parent.parent / "master_test_suite" / "expected_outputs" / "{subcategory}" / "{pdf_stem}"


def compute_md5(file_path):
    """Compute MD5 hash of file"""
    md5 = hashlib.md5()
    with open(file_path, 'rb') as f:
        while chunk := f.read(8192):
            md5.update(chunk)
    return md5.hexdigest()


{markers_decorators}
def test_text_extraction_{test_name}({pdfs_fixture}, extract_text_tool_dispatcher, optimized_lib, expected_outputs):
    """Text extraction correctness for {pdf_name}"""
    pdf_path = {pdfs_fixture} / PDF_REL_PATH
    manifest_path = EXPECTED_DIR / "manifest.json"

    assert pdf_path.exists(), f"PDF not found: {{pdf_path}}"
    assert manifest_path.exists(), f"Manifest not found: {{manifest_path}}"

    # Load manifest
    with open(manifest_path) as f:
        manifest = json.load(f)

    # Check for error manifest (unloadable PDF)
    if manifest.get("load_result") == "FPDF_LOAD_FAILED":
        # Validate that extraction fails gracefully
        env = os.environ.copy()
        env['DYLD_LIBRARY_PATH'] = str(optimized_lib.parent)

        with tempfile.NamedTemporaryFile(suffix='.txt', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            result = subprocess.run(
                [str(extract_text_tool_dispatcher), "--encoding", "utf32le", "extract-text", str(pdf_path), str(tmp_path)],
                capture_output=True,
                env=env,
                timeout=600
            )
            # Validate graceful failure
            assert result.returncode != 0, "Expected non-zero exit code for unloadable PDF"
            stderr_text = result.stderr.decode()
            assert ("Failed to load PDF" in stderr_text or "Failed to read page count" in stderr_text), \
                "Expected load failure message"
        finally:
            if tmp_path.exists():
                tmp_path.unlink()

        # Test passed - validated graceful failure handling
        return

    # Check for 0-page PDF (loads successfully but should handle gracefully)
    if manifest.get("pdf_pages") == 0:
        # Test graceful handling of 0-page PDF
        env = os.environ.copy()
        env['DYLD_LIBRARY_PATH'] = str(optimized_lib.parent)

        with tempfile.NamedTemporaryFile(suffix='.txt', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            result = subprocess.run(
                [str(extract_text_tool_dispatcher), "--encoding", "utf32le", "extract-text", str(pdf_path), str(tmp_path)],
                capture_output=True,
                env=env,
                timeout=600
            )
            assert result.returncode == 0, f"Should handle 0-page PDF gracefully: {{result.stderr.decode()}}"
            # C++ CLI outputs UTF-32 LE BOM (4 bytes) for empty text
            assert tmp_path.stat().st_size == 4, "Should produce 4-byte BOM for 0-page PDF"
        finally:
            if tmp_path.exists():
                tmp_path.unlink()

        # Test passed - validated graceful 0-page handling
        return

    # Set up environment for shared library
    env = os.environ.copy()
    env['DYLD_LIBRARY_PATH'] = str(optimized_lib.parent)

    # Act: Extract text using C++ CLI tool (bulk mode, auto-dispatch)
    # Use UTF-32LE encoding to match baseline format (v2.0.0 defaults to UTF-8)
    with tempfile.NamedTemporaryFile(suffix='.txt', delete=False) as tmp:
        tmp_path = Path(tmp.name)

    try:
        result = subprocess.run(
            [str(extract_text_tool_dispatcher), "--encoding", "utf32le", "extract-text", str(pdf_path), str(tmp_path)],
            capture_output=True,
            env=env,
            timeout=600
        )
        assert result.returncode == 0, f"Extraction failed: {{result.stderr.decode()}}"

        # Read actual output
        actual_text = tmp_path.read_bytes()
    finally:
        # Clean up temp file
        if tmp_path.exists():
            tmp_path.unlink()

    # Assert: Compare with expected full text
    expected_full_path = EXPECTED_DIR / manifest["text"]["full"]["path"]
    expected_text = expected_full_path.read_bytes()

    assert actual_text == expected_text, f"Text mismatch for {{PDF_NAME}}"


{markers_decorators}
def test_jsonl_extraction_{test_name}({pdfs_fixture}, optimized_lib, expected_outputs, pdfium_root):
    """JSONL extraction for {pdf_name} (page 0 only)"""
    pdf_path = {pdfs_fixture} / PDF_REL_PATH
    manifest_path = EXPECTED_DIR / "manifest.json"

    assert pdf_path.exists(), f"PDF not found: {{pdf_path}}"
    assert manifest_path.exists(), f"Manifest not found: {{manifest_path}}"

    # Load manifest
    with open(manifest_path) as f:
        manifest = json.load(f)

    # Find extract_text_jsonl binary
    extract_jsonl_bin = pdfium_root / 'rust' / 'target' / 'release' / 'examples' / 'extract_text_jsonl'

    # Set up environment for shared library
    env = os.environ.copy()
    env['DYLD_LIBRARY_PATH'] = str(optimized_lib.parent)

    # Check for error manifest (unloadable PDF) - TEST graceful failure
    if manifest.get("load_result") == "FPDF_LOAD_FAILED":
        # JSONL extraction should fail gracefully for unloadable PDFs
        # This tests error handling, not a skip
        with tempfile.NamedTemporaryFile(suffix='.jsonl', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            result = subprocess.run(
                [str(extract_jsonl_bin), str(pdf_path), str(tmp_path), '0'],
                capture_output=True,
                env=env,
                timeout=600
            )
            # Validate graceful failure
            assert result.returncode != 0, "Expected non-zero exit code for unloadable PDF"
            stderr_text = result.stderr.decode()
            assert ("Failed to load PDF" in stderr_text or "Failed to read page count" in stderr_text), \\
                "Expected load failure message"
        finally:
            if tmp_path.exists():
                tmp_path.unlink()

        # Test passed - validated graceful failure handling
        return

    # Check if JSONL is available for this PDF (0-page PDFs) - TEST graceful handling
    if not manifest["jsonl"]["pages"]:
        # For 0-page PDFs, JSONL should produce empty output or fail gracefully
        # This tests edge case handling, not a skip
        with tempfile.NamedTemporaryFile(suffix='.jsonl', delete=False) as tmp:
            tmp_path = Path(tmp.name)

        try:
            result = subprocess.run(
                [str(extract_jsonl_bin), str(pdf_path), str(tmp_path), '0'],
                capture_output=True,
                env=env,
                timeout=600
            )
            # For 0-page PDFs, extraction might fail or produce empty output
            # Either is acceptable graceful behavior
            if result.returncode != 0:
                # Failed gracefully (expected for 0-page)
                pass
            else:
                # Succeeded with empty output (also acceptable)
                assert tmp_path.stat().st_size == 0, "Should produce empty JSONL for 0-page PDF"
        finally:
            if tmp_path.exists():
                tmp_path.unlink()

        # Test passed - validated graceful 0-page handling
        return

    # Check if JSONL baseline file actually exists on disk
    expected_jsonl_path = EXPECTED_DIR / manifest["jsonl"]["pages"][0]["path"]
    if not expected_jsonl_path.exists():
        pytest.skip(f"JSONL baseline not found: {{expected_jsonl_path}}")

    # Normal case: Extract JSONL for page 0
    with tempfile.NamedTemporaryFile(suffix='.jsonl', delete=False) as tmp:
        tmp_path = Path(tmp.name)

    try:
        result = subprocess.run(
            [str(extract_jsonl_bin), str(pdf_path), str(tmp_path), '0'],
            capture_output=True,
            env=env,
            timeout=600
        )
        assert result.returncode == 0, f"JSONL extraction failed: {{result.stderr.decode()}}"

        # Read actual output
        actual_jsonl = tmp_path.read_bytes()
    finally:
        # Clean up temp file
        if tmp_path.exists():
            tmp_path.unlink()

    # Assert: Compare with expected JSONL
    expected_jsonl = expected_jsonl_path.read_bytes()

    assert actual_jsonl == expected_jsonl, "JSONL mismatch on page 0"
'''


def generate_markers(pdf_row):
    """Build marker decorators for test"""
    markers_str = pdf_row['markers'].strip()
    if not markers_str:
        return ""

    markers_list = [m.strip() for m in markers_str.split(',') if m.strip()]
    decorators = '\n'.join(f'@pytest.mark.{m}' for m in markers_list)
    return decorators


def generate_test_file(pdf_row, output_base_dir):
    """Generate one test file with 3 test functions"""
    category = pdf_row['pdf_category']
    subcategory = pdf_row['pdf_subcategory']
    pdf_name = pdf_row['pdf_name']
    pdf_stem = Path(pdf_name).stem

    # Create safe test name (replace special characters)
    test_name = pdf_stem.replace('-', '_').replace(' ', '_').replace('.', '_')

    # Determine output directory based on subcategory
    output_dir = output_base_dir / subcategory
    output_dir.mkdir(parents=True, exist_ok=True)

    # Extract just the filename from pdf_path for relative path
    # pdf_path is like "pdfs/benchmark/arxiv_001.pdf"
    # benchmark_pdfs fixture already points to "pdfs/benchmark/"
    # so we just need the filename
    pdf_filename = Path(pdf_row['pdf_path']).name

    # Determine fixture name based on category (not subcategory)
    # Category = benchmark, edge_cases (directory structure)
    # Subcategory = arxiv, cc, edinet, web, pages (logical grouping)
    pdfs_fixture = f"{category}_pdfs"

    # Generate file content
    markers_decorators = generate_markers(pdf_row)
    content = TEMPLATE.format(
        pdf_name=pdf_name,
        pdf_stem=pdf_stem,
        test_name=test_name,
        category=category,
        subcategory=subcategory,
        size_class=pdf_row['pdf_size_class'],
        pages=pdf_row['pdf_pages'],
        markers=pdf_row['markers'],
        markers_decorators=markers_decorators,
        rel_path=pdf_filename,
        pdfs_fixture=pdfs_fixture
    )

    # Write file
    test_file = output_dir / f'test_{test_name}.py'
    test_file.write_text(content)
    print(f"Generated {test_file.relative_to(output_base_dir.parent)}")

    return test_file


def main():
    """Generate all test files from manifest"""
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    manifest_path = project_root / 'master_test_suite' / 'pdf_manifest.csv'
    output_dir = project_root / 'tests' / 'pdfs'

    if not manifest_path.exists():
        print(f"ERROR: Manifest not found: {manifest_path}", file=sys.stderr)
        sys.exit(1)

    # Clear existing test files
    if output_dir.exists():
        print(f"Clearing existing tests in {output_dir}...")
        for test_file in output_dir.rglob('test_*.py'):
            test_file.unlink()

    output_dir.mkdir(parents=True, exist_ok=True)

    # Read manifest and generate tests
    generated_count = 0
    with open(manifest_path) as f:
        reader = csv.DictReader(f)
        for row in reader:
            try:
                generate_test_file(row, output_dir)
                generated_count += 1
            except Exception as e:
                print(f"ERROR generating test for {row.get('pdf_name', 'UNKNOWN')}: {e}", file=sys.stderr)

    print(f"\nâœ“ Generated {generated_count} test files ({generated_count * 2} test functions: text, jsonl)")


if __name__ == '__main__':
    main()
